\input texinfo      @c -*-texinfo-*-
@c Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011
@c Rocky Bernstein for the Free Software Foundation
@c
@c TODO:
@c   - add examples for commands
@c   - clean up/improve sample session
@c   - help text is inaccurate and formatted too much to right.
@c

@c Sets version and release names and dates. Frees us from changing
@c this file when a new release comes along.

@c %**start of header
@c makeinfo ignores cmds prev to setfilename, so its arg cannot make use
@c of @set vars.  However, you can override filename with makeinfo -o.
@setfilename bashdb.info
@c
@c Name of Bash program.  Used in running text.

@c
@c Name of debugger program.  Used also for prompt string.
@set BASH @acronym{BASH}
@set DBG the @value{BASH} debugger
@set dBGP The @value{BASH} debugger
@set DDD @acronym{DDD}
@set Emacs @sc{gnu} Emacs

@settitle @value{BASH} Debugger
@setchapternewpage odd
@c %**end of header

@include version.texi
@include macros.texi

@c Karl Berry informs me that this will add straight quotes in
@c typewriter text.
@c See the "Inserting Quote Characters" node in the Texinfo manual
@set txicodequoteundirected
@set txicodequotebacktick

@iftex
@c @smallbook
@c @cropmarks
@end iftex

@finalout

@c readline appendices use @vindex, @findex and @ftable,
@c annotate.texi and gdbmi use @findex.
@c @syncodeindex vr cp
@c @syncodeindex fn cp

@c THIS MANUAL REQUIRES TEXINFO 4.0 OR LATER.

@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.
@dircategory Programming & development tools.
@direntry
* Bashdb - the bash debugger: (bashdb). The @sc{bash} debugger
@end direntry

@ifinfo
This file documents the @sc{bash} debugger @value{BASH}.


This is the @value{EDITION} Edition, @value{UPDATED},
of @cite{Debugging with BASHDB: the @sc{gnu} Source-Level Debugger}
for BASH

Copyright (C) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011
Rocky Bernstein for the Free Software Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
@ifset DEBIANHASBECOMEREASONABLE
@c From Matthias Klose <doko@debian.org> a Debian maintainer on
@c Sat, 23 Aug 2003 14:24:44 +0200
@c
@c  I personally see the invariant sections as the thing in the
@c  GFDL, which hinders me in uploading the package to the archives.
@c  I don't have any problem, if some other Debian developer makes a
@c  bashdb package built from separate sources.
@c
@c  I am aware that Debian ships other packages containing documentation
@c  covered by the GFDL (and one of them for which I do the packaging as
@c  well), but I won't add a new package, which I maintain. So before an
@c  upload of a bashdb package built from the bash sources either
@c
@c
@c  - Debian has a position on the GFDL, which allows inclusion
@c
@c  - the bashdb manual does not have invariant sections, or is
@c    relicensed, or dual licensed.
@c
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Free Software'' and ``Free Software Needs
Free Documentation'', with the Front-Cover Texts being ``A GNU
Manual,'' and with the Back-Cover Texts as in (a) below.

(a) The Free Software Foundation's Back-Cover Text is: ``You have
freedom to copy and modify this GNU Manual, like GNU software.  Copies
published by the Free Software Foundation raise funds for GNU
development.''
@end ifset
@ifclear DEBIANHASBECOMEREASONABLE
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end ifclear
@end ifinfo

@titlepage
@title Debugging with BASHDB
@sp 1
@subtitle @value{EDITION} Edition, for BASH
@subtitle @value{UPDATED-MONTH}
@author Rocky Bernstein
@page
@c @tex
@c {\parskip=0pt
@c \hfill (Send bugs and comments on @emph{bashdb} to bug-bashdb\@sourceforge.net.)\par
@c \hfill {\it Debugging with BASH}\par
@c \hfill \TeX{}info \texinfoversion\par
@c }
@c @end tex

@vskip 0pt plus 1filll
Copyright @copyright{} 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein for the Free Software
Foundation.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
@ifset DEBIANHASBECOMEREASONABLE
@c From Matthias Klose <doko@debian.org> a Debian maintainer on
@c Sat, 23 Aug 2003 14:24:44 +0200
@c
@c  I personally see the invariant sections as the thing in the
@c  GFDL, which hinders me in uploading the package to the archives.
@c  I don't have any problem, if some other Debian developer makes a
@c  bashdb package built from separate sources.
@c
@c  I am aware that Debian ships other packages containing documentation
@c  covered by the GFDL (and one of them for which I do the packaging as
@c  well), but I won't add a new package, which I maintain. So before an
@c  upload of a bashdb package built from the bash sources either
@c
@c
@c  - Debian has a position on the GFDL, which allows inclusion
@c
@c  - the bashdb manual does not have invariant sections, or is
@c    relicensed, or dual licensed.
@c
@c
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Free Software'' and ``Free Software Needs
Free Documentation'', with the Front-Cover Texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.

(a) The Free Software Foundation's Back-Cover Text is: ``You have
freedom to copy and modify this GNU Manual, like GNU software.  Copies
published by the Free Software Foundation raise funds for GNU
development.''
@end ifset
@ifclear DEBIANHASBECOMEREASONABLE
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
@end ifclear
@end titlepage
@page

@ifnottex
@node Top, Summary, (dir), (dir)

@top Debugging with @DBG

This file describes @value{DBG}, the @sc{bash} symbolic debugger.

This is the @value{EDITION} Edition, @value{UPDATED}, for BASH.

Copyright (C) 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein

@menu
* Summary::                     Overview of Debugger with a sample session

* Invocation::                  Getting in and out
* Running::                     Script setup inside the BASH debugger
* Debugger Command Reference::  BASH debugger command reference

* BASH Debugger Bugs::          Reporting bugs
* History and Acknowledgments:: History and Acknowledgments

Appendices
* Copying::			GNU General Public License says
                                how you can copy and share bashdb
* GNU Free Documentation License::  The license for this documentation

Indexes (nodes containing large menus)
* Command Index::             An item for each command name.
* General Index::             An item for each concept.
@end menu

@end ifnottex

@contents

@node Summary
@chapter Summary of the BASH Debugger

The purpose of a debugger such as @DBG is to allow you to see what is
going on ``inside'' a bash script while it executes.

@DBG can do four main kinds of things (plus other things in support of
these) to help you catch bugs in the act:

@itemize @bullet
@item
Start your script, specifying anything that might affect its behavior.

@item
Make your script stop on specified conditions.

@item
Examine what has happened, when your script has stopped.

@item
Change things in your script, so you can experiment with correcting the
effects of one bug and go on to learn about another.
@end itemize

Although you can use the @acronym{BASH} debugger to debug scripts
written in @acronym{BASH}, it can also be used just as a front-end
for learning more about programming in @acronym{BASH}. As an
additional aid, the debugger can be used within the context of an
existing script with its functions and variables that have already
been initialized; fragments of the existing can be experimented with
by entering them inside the debugger.

@menu
* Sample Session::                    A Sample BASH Debugger session
* Interactive Line Tracing Session::  Interactive Line Tracing Session
@end menu

@node Sample Session
@section A Sample BASH Debugger Session

You can use this manual at your leisure to read all about @value{DBG}.
However, a handful of commands are enough to get started using the
debugger.  This chapter illustrates those commands.

@iftex
In this sample session, we emphasize user input like this: @b{input},
to make it easier to pick out from the surrounding output.
@end iftex

Below we will debug a script that contains a function to compute the
factorial of a number: fact(0) is 1 and fact(n) is n*fact(n-1).

@smallexample
$ @b{bashdb -L .  /tmp/fact.sh}
Bourne-Again Shell Debugger, release bash-@value{VERSION}
Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein
This is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.

(/tmp/fact.sh:9):
  9:	echo fact 0 is: `fact 0`
bashdb<0> @b{-}
  1:    #!/usr/local/bin/bash
  2:    fact() @{
  3:    ((n==0)) && echo 1 && return
  4:    ((nm1=n-1))
  5:    ((result=n*`fact $nm1`))
  6:    echo $result
  7:    @}
  8:
  9:==> echo fact 0 is: `fact 0`
bashdb<1> @b{list}
 10:   echo fact 3 is: $(fact 3)
@end smallexample

@noindent

The command invocation uses the option ``-L .'' Here we assume that
the @command{bashdb} script and the debugger files are in the same
location. If you are running from the source code, this will be the
case. However if @emph{bashdb} has been installed this probably won't be true
and here you probably don't need to use ``-L .'' Instead you would
type simply @code{bashdb /tmp/fact.sh}.

Position information consists of a filename and line number,
e.g. @code{(/tmp/fact.sh:9)} and is given parenthesis. This position
format is similar to that used in a dozen or so other debuggers; GNU
Emacs and DDD can parse this format.

In the first debugger command we gave @kbd{-}, we listed a window of
lines @emph{before} where we were executing. Because the window, 10
lines, is larger than the number of lines to the top of the file we
printed only 9 lines here. The next command, @code{list}, starts from
the current line and again wants to print 10 lines but because there
are only one remaining line, that is what is printed.

@smallexample
@cartouche
bashdb<2> @b{step}
(/tmp/fact.sh:9):
fact 0
9:	echo fact 0 is: `fact 0`
bashdb<(3)> @b{@key{RET}}
2:	fact() @{
bashdb<(4)> @b{@key{RET}}
3:	((n==0)) && echo 1 && return
bashdb<(5)> @b{print $n}

bashdb<(6)>
@end cartouche
@end smallexample

Ooops... The variable @kbd{n} isn't initialized.@footnote{Recall that
variables in @value{BASH} don't need to be declared before they are
referred to and that the default value would be the a null value which
here prints as an empty string.}

The first @kbd{step} command steps the script one instruction. It may
seem odd that the line printed is exactly the same one as before. What
has happened though is that we've ``stepped'' into the subshell needed
to run @kbd{`fact 0`}; we haven't however started running anything
inside that subshell yet though.

To indicate that which piece of the multi-part line @code{echo fact 0
is: `fact 0`} we show that part all by itself @kbd{fact 0}. If nothing
is shown then it means we are running the beginning statement or in
this case the outermost statement.

To indicate that we are now nested in a subshell, notice that the
command number, starting with 3, or the third command entered, now
appears in parenthesis. Each subshell nesting adds a set of
parenthesis.

The first @kbd{step} command steps the script one instruction; it
didn't advance the line number, 9, at all. That is because we were
stopping before the command substitution or backtick is to take
place. The second command we entered was just hitting the return key;
@emph{bashdb} remembers that you entered @code{step} previously, so it runs
the step rather than @kbd{next}, the other alternative when you hit
@key{RET}. Step one more instruction and we are just before running
the first statement of the function.

Next, we print the value of the variable @kbd{n}. Notice we need to add
a preceding dollar simple to get the substitution or value of n. As we
will see later, if the @kbd{pe} command were used this would not be
necessary.

We now modify the file to add an assignment to local variable @kbd{n} and
restart.

@smallexample
@cartouche
bashdb<6> @b{restart}
Restarting with: /usr/local/bin/bashdb -L . fact.sh
(/tmp/fact.sh:10):
10:	echo fact 0 is: `fact 0`
bashdb<0> @b{list 1}
  1:    #!/usr/local/bin/bash
  2:    fact() @{
  3:    local -i n=$@{1:0@}
  4:    ((n==0)) && echo 1 && return
  5:    ((nm1=n-1))
  6:    ((result=n*`fact $nm1`))
  7:    echo $result
  8:    @}
  9:
 10:==> echo fact 0 is: `fact 0`
bashdb<1> @b{s 3}
(/tmp/fact.sh:3):
3:	local -i n=$@{1:0@}
bashdb<(2)> @b{step}
(/tmp/fact.sh:4):
4:	((n==0)) && echo 1 && return
bashdb<(3)> @b{print $n}
print $n
0
@end cartouche
@end smallexample

@noindent
This time we use the @code{list} debugger command to list the lines in
the file. From before we know it takes three @code{step} commands
before we get into the fact() function, so we add a count onto the
@code{step} command. Notice we abbreviate @code{step} with @code{s};
we could have done likewise and abbreviated @code{list} with @code{l}.

@smallexample
@cartouche
bashdb<(4)> @b{@key{RET}}
(/tmp/fact.sh:4):
4:	((n==0)) && echo 1 && return
echo 1
bashdb<(5)> @b{@key{RET}}
(/tmp/fact.sh:4):
4:	((n==0)) && echo 1 && return
return
@end cartouche
@end smallexample

@noindent
Again we just use @key{RET} to repeat the last @code{step}
commands. And again the fact that we are staying on the same line 4
means that the next condition in the line is about to be
executed. Notice that we see the command (@code{echo 1} or
@code{return}) listed when we stay on the same line which has multiple
stopping points in it. Given the information above, we know that the
value echo'ed on return will be 1.

@smallexample
@cartouche
bashdb<(6)> @b{@key{RET}}
fact 0 is: 1
(/tmp/fact.sh:12):
12:	echo fact 3 is: $(fact 3)
bashdb<(7)> @b{break 5}
Breakpoint 1 set in file fact.sh, line 5.
bashdb<(8)> @b{continue}
@end cartouche
@end smallexample

@noindent
We saw that we could step with a count into the function
fact(). However above took another approach: we set a stopping point or
``breakpoint'' at line 5 to get us a little ways into the fact()
subroutine. Just before line 5 is to executed, we will get back into
the debugger. The @code{continue} command just resumes execution until
the next stopping point which has been set up in some way.

@smallexample
@cartouche
(/tmp/fact.sh:5):
5:      ((nm1=n-1))
Breakpoint 1 hit(1 times).
bashdb<(8)> @b{x n-1}
2
bashdb<(9)> @b{s}
(/tmp/fact.sh:5):
6:     ((result=n*`fact $nm1`))
bashdb<(10)> @b{c}
fact.sh: line 6: ((: result=n*: syntax error: operand expected (error token is "*")
bashdb<(7)> @b{R}
Restarting with: bash --debugger fact.sh
11:	echo fact 0 is: `fact 0`
bashdb<0> @b{l fact}
 2:    fact ()
 3:    @{
 4:       local -i n=$@{1:0@};
 5:       (( "n==0" )) && echo 1 && return;
 6:       (( nm1=n-1 ));
 7:       ((fact_nm1=`fact $nm1`))
 8:       (( "result=n*fact_nm1" ));
 9:       echo $result
10:    @}
@end cartouche
@end smallexample

@noindent
In addition to listing by line numbers, we can also list giving a
function name. Below, instead of setting a breakpoint at line 5 and
running ``@code{continue}'' as we did above, we try something slightly
shorter and slightly different. We give the line number on the
``continue'' statement. This is a little different in that a one-time
break is made on line 5. Once that statement is reached the breakpoint
is removed.

@smallexample
@cartouche
bashdb<1> @b{continue 5}
One-time breakpoint 1 set in file fact.sh, line 5.
fact 0 is: 1
(/tmp/fact.sh:5):
5:	((nm1=n-1))
bashdb<(2)> @b{s}
6:	((fact_nm1=`fact $nm1`))
bashdb<(3)> @b{s}
2:	fact() @{
bashdb<(4)> @b{T}
->0 in file `fact.sh' at line 2
##1 fact("3") called from file `fact.sh' at line 12
##2 source("fact.sh") called from file `/usr/local/bin/bashdb' at line 154
##3 main("fact.sh") called from file `/usr/local/bin/bashdb' at line 0
bashdb<(5)> @b{c}
fact 3 is: 6
Debugged program terminated normally. Use q to quit or R to restart.
@end cartouche
@end smallexample

@noindent
When we stop at line 5 above, we have already run fact(0) and output
the correct results. The output from the program ``fact 0 is: 1'' is
intermixed with the debugger output. The @code{T} command above
requests call stack output and this confirms that we are not in the
fact(0) call but in the fact(3) call. There are 4 lines listed in the
stack trace even though there is just one call from the main
program. The top line of the trace doesn't really represent a call,
it's just where we currently are in the program. That last line is an
artifact of invoking bash from the bashdb script rather than running
@code{bash --debugger}.

The last message in the output above @samp{Debugged program exited
normally.} is from @value{DBG}; it indicates script has finished
executing.  We can end our @emph{bashdb} session with the @code{quit}
command.

Above we did our debugging session on the command line. If you are a
GNU Emacs user, you can do your debugging inside that. Also there is
a(nother) GUI interface called DDD that supports @value{DBG}.

@node Interactive Line Tracing Session
@section Interactive Line Tracing Session
@anchor{PS4}
@cindex @code{$PS4}

One of the things I had found disappointing about the
default @code{set -x} tracing behavior is that no position information
is given in the trace output, in particular the line number and the file
name.  However with the introduction in Bash 3.0 of the introspection
variables, also needed to support the debugger, one can set
@code{$PS4} to rectify this. (I became of this in a defunct blog
@url{http://raz.cx/blog/2005/08/handy-bash-debugging-trick.html}.)

Here's what I use:
@smallexample
  PS4='($@{BASH_SOURCE@}:$@{LINENO@}): $@{FUNCNAME[0]@} - [$@{SHLVL@},$@{BASH_SUBSHELL@}, $?]
'
@end smallexample
Note that the string is in single quotes, not double quotes and there
is a newline in the string. By using single quotes, variables which
have a dollar in front of them in the string are expanded in the
current environment of the line that is about to be run rather than at
the time the variable @code{PS4} is set.

You might want to add this in your shell's start-up script, e.g.,
@code{.bashrc}, or @code{.profile}.

There is also facility inside the bash debugger showing position
information when tracing a script. Here's a simple session.

@smallexample
@b{/usr/local/bin/bashdb /tmp/fact.sh}
Bourne-Again Shell Debugger, release bash-@value{VERSION}
Copyright 2002, 2003, 2004, 2006, 2007, 2008 Rocky Bernstein
This is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.

(/tmp/fact.sh:11):
11:	echo fact 0 is: `fact 0`
bashdb<0> @b{set linetrace on}
bashdb<1> @b{cont}
(/tmp/fact.sh:11):
level 1, subshell 1, depth 0:	echo fact 0 is: `fact 0`
fact 0
(/tmp/fact.sh:2):
level 1, subshell 1, depth 1:	fact() @{
(/tmp/fact.sh:3):
level 1, subshell 1, depth 1:	    local -i n=$@{1:0@}
(/tmp/fact.sh:4):
level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
(/tmp/fact.sh:4):
level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
echo 1
(/tmp/fact.sh:4):
level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
return
fact 0 is: 1
(/tmp/fact.sh:13):
level 1, subshell 0, depth 0:	echo fact 3 is: $(fact 3)
(/tmp/fact.sh:13):
level 1, subshell 1, depth 0:	echo fact 3 is: $(fact 3)
fact 3
(/tmp/fact.sh:2):
level 1, subshell 1, depth 1:	fact() @{
(/tmp/fact.sh:3):
level 1, subshell 1, depth 1:	    local -i n=$@{1:0@}
(/tmp/fact.sh:4):
level 1, subshell 1, depth 1:	    ((n==0)) && echo 1 && return
(/tmp/fact.sh:5):
level 1, subshell 1, depth 1:	    ((nm1=n-1))
(/tmp/fact.sh:6):
level 1, subshell 1, depth 1:	    ((fact_nm1=`fact $nm1`))
(/tmp/fact.sh:6):
level 1, subshell 2, depth 1:	    ((fact_nm1=`fact $nm1`))
fact $nm1
(/tmp/fact.sh:2):
level 1, subshell 2, depth 2:	fact() @{
...
level 1, subshell 4, depth 4:	fact() @{
(/tmp/fact.sh:3):
level 1, subshell 4, depth 4:	    local -i n=$@{1:@}
(/tmp/fact.sh:4):
level 1, subshell 4, depth 4:	    ((n==0)) && echo 1 && return
(/tmp/fact.sh:4):
level 1, subshell 4, depth 4:	    ((n==0)) && echo 1 && return
echo 1
(/tmp/fact.sh:4):
level 1, subshell 4, depth 4:	    ((n==0)) && echo 1 && return
return
(/tmp/fact.sh:7):
level 1, subshell 3, depth 3:	    ((result=n*fact_nm1))
(/tmp/fact.sh:8):
level 1, subshell 3, depth 3:	    echo $result
(/tmp/fact.sh:7):
level 1, subshell 2, depth 2:	    ((result=n*fact_nm1))
(/tmp/fact.sh:8):
level 1, subshell 2, depth 2:	    echo $result
(/tmp/fact.sh:7):
level 1, subshell 1, depth 1:	    ((result=n*fact_nm1))
(/tmp/fact.sh:8):
level 1, subshell 1, depth 1:	    echo $result
fact 3 is: 6
(/usr/local/bin/bashdb:260):
level 1, subshell 0, depth -1:
Debugged program terminated normally. Use q to quit or R to restart.
bashdb<2>
@end smallexample

An explanation of the output. The @emph{level} is how many invocations
of @value{BASH} are in effect before the statement shown is
executed. The @emph{subshell} is how many subshells you are nested
in. Subshells are used by command substitution---@code{`..'} and
@code{$(...)}---as well as arithmetic expressions @code{((...))}. The
@emph{depth} is the function depth or how many calls you are nested
in. A ``source'' command also increases this depth.

Notice also that in contrast to @code{set -x} tracing, the line shown
is exactly as you entered it in the source. So if you indented
statements in a meaningful way, it will help you understand the
statement nesting level. But as before, if a line contains multiple
statements, you are @emph{not} executing the first statement in the
line and @code{set showcommand} is not turned off (by default it is
on), that statement is shown in addition below the multi-statement
line. Such an example can be seen right at the beginning where
@code{fact 0} is shown.

If what you want to do is trace the @emph{entire} script as was done
above (and not stop in the debugger when the script is over), you can
get the same effect by using the @code{-X} or @code{--trace} option on
the @emph{bashdb} command:

@smallexample
@b{/usr/local/bin/bashdb -X /tmp/fact.sh}
Bourne-Again Shell Debugger, release bash-@value{VERSION}
Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein
This is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.

(/usr/local/bin/bashdb:272):
level 1, subshell 0, depth -1:	  . $_source_file
(/tmp/fact.sh:11):
level 1, subshell 0, depth 0:	echo fact 0 is: `fact 0`
(/tmp/fact.sh:11):
level 1, subshell 1, depth 0:	echo fact 0 is: `fact 0`
fact 0
(/tmp/fact.sh:2):
level 1, subshell 1, depth 1:	fact() @{
(/tmp/fact.sh:3):
level 1, subshell 1, depth 1:	    local -i n=$@{1:0@}
...
level 1, subshell 2, depth 2:	    echo $result
(/tmp/fact.sh:7):
level 1, subshell 1, depth 1:	    ((result=n*fact_nm1))
(/tmp/fact.sh:8):
level 1, subshell 1, depth 1:	    echo $result
fact 3 is: 6
(/usr/local/bin/bashdb:285):
level 1, subshell 0, depth -1:
@end smallexample

If you issue a break (e.g.@: send a @code{SIGINT} signal) while the
program is running you will go into the debugger (assuming your
program doesn't trap @code{SIGINT}).

@node Invocation
@chapter Getting in and out

This chapter discusses how to start @value{DBG}, and how to get out of it.
The essentials are:
@itemize @bullet
@item
type @samp{bash --debugger @emph{script-name}} or @samp{bashdb
@emph{script-name}} to start @value{DBG}. Or...
@item
type @samp{bashdb -c @emph{command string}} to give a string to run
under the debugger. Or ..
@item
modify your program to enter the debugger at a particular point:
@code{source ../bashdb-trace} and @code{_Dbg_debugger}.
@item
type @kbd{quit} or @kbd{C-d} inside the debugger to exit.
@end itemize

There are also two front-ends available as well. An emacs front-end
which has @emph{bashdb} support among others is @url{https://github.com/rocky/emacs-dbgr/wiki}.

@menu
* Starting the BASH debugger::    How to enter the BASH debugger
* Quitting the BASH debugger::    How to leave the BASH debugger
* Calling from Program::          Calling the debugger from inside your program
@end menu

@node Starting the BASH debugger
@section Starting the BASH debugger

@emph{Note: it is important to use a debugger-enabled bash. You will
get an error message if the debugger is run under a version of BASH
that does not have debugging support.}

As mentioned above, one can enter @DBG via Emacs or
DDD. However you don't have to use either of these. And these still
need a way on their own to get things started.

There are in fact two @emph{other} ways to start @value{DBG}.  The
first way is to pass the @samp{--debugger} option to bash with the
name of your script the scripts arguments following that, or with a
command string (@code{-c}).

@example
bash --debugger @var{script} @var{script-arguments...}
bash --debugger -c @var{command-string}...
@end example

This calls a debugger initialization script. It works much like a
@acronym{BASH} login profile which may set variables and define
functions. But this shell profile is customized for debugging and as
such arranges for itself to get called before each statement is
executed. Although there are some problems at present in I/O
redirection that the method described next doesn't have, it is
expected that over time more features will be enabled in bash when the
@samp{--debugger} option is in effect.

The form @samp{bash --debugger -c ...} can be used to get into the
debugger without having to give a script name to debug. Sometimes you
may want to do this just to see how the debugger works: try some
debugger commands or maybe get online help. If you run @code{ddd
--bash} without giving a script name, it in fact uses this form.

In order for the @samp{--debugger} option to work however, you must
have the debugger scripts installed in a place where @DBG can find
them. For this reason, in developing @value{DBG}, I use a second
method more often; it doesn't require the bash debugger to be
installed. This method uses another script called @emph{bashdb} which
allows for giving its own options, the final option is signaled by
adding @code{--}). After this, the name of the script to debugged and
any the arguments to pass to that script are given. Using this method,
one would start the debugger like this:

@example
bash @var{path-to-bashdb}/bashdb @var{bashdb-options} -- @var{script} @var{script-arguments...}
@end example

If you don't need to pass dash options to your program which might get
confused with the debugger options, then you don't need to add the
@code{--}.@footnote{And in the interest of full disclosure, although
this was not shown in the example it is possible to add the @code{--}
@emph{after} the script name to be debugged but before the first
program option with a dash.}

As with the first method, @code{bash} should be a debugger-enabled
bash. If @emph{bashdb} has the path to bash in it at the top (e.g.@: via
@code{#!}), and @emph{bashdb} can be found in your program-search
path, then this might be equivalent to the above:

@example
bashdb @var{bashdb-options} -- @var{script} @var{script-arguments...}
@end example

There are two or three disadvantages however of running a debugger
this way. First @code{$0} will have the value @emph{bashdb} rather
than the script you are trying to run. For some scripts this may
change the behavior of the debugged script. Second a traceback will
contain additional lines showing the ``source''-ing of the debugged
script from @emph{bashdb}. And third, although this way works better
than the first method, over time this way may come into disuse.

An option that you'll probably need to use if bashdb isn't installed
but run out of the source code directory is @samp{-L} which specifies
the directory that contains the debugger script files.

You can further control how bashdb starts up by using command-line
options. bashdb itself can remind you of the options available.

@noindent
Type

@example
bashdb -h
@end example

@noindent
to display all available options and briefly describe their use.

When the bash debugger is invoked either by the @emph{bashdb}
front-end script or @code{bash --debugging}, the first argument that
does not have an associated option flag for @emph{bashdb} or
@code{bash} (as the case may be) is used as the name a the script file
to be debugged, and any following options get passed the debugged
script.

Options for the @emph{bashdb} front-end are shown in the
following list.

@menu
* Options for the bashdb script::   Options you can pass in starting bashdb
@end menu

@node Options for the bashdb script
@subsection Command-line options for @emph{bashdb} script

You can run @DBG in various alternative modes---for example, in batch
mode or quiet mode.

@table @code
@item -h | --help
@cindex @code{-h}
@cindex @code{--help}
This option causes @value{DBG} to print some basic help and exit.

@item -V | --version
@cindex @code{-V}
This option causes @DBG to print its version number,
no-warranty blurb, and exit.

@item -A | --annodate @var{level}
@cindex @code{-A}
@cindex @code{--annotate}
Add additional output which allows front-ends to track what's going on
without having to poll for such vital information. The default
annotation level is 0 (none). If you are running inside GNU Emacs
using the Emacs code from this package, an annotation level 3 when set
will allow for automatic tracking of frames and
breakpoints. @xref{Annotate}.

@item -c | --command @var{cmd}
@cindex @code{-c}
@cindex @code{--command}
Run the string instead of running a script

@item -B | --basename
@cindex @code{-B}
@cindex @code{--basename}
This option causes @DBG to print its version number and
no-warranty blurb, and exit.

@item -n | --nx | --no-init
@cindex @code{-n}
@cindex @code{--nx}
@cindex @code{--no-init}
Do not execute commands found in any initialization files.  Normally,
@acronym{BASH} executes the commands in these files after all the command
options and arguments have been processed.  @xref{Command Files,,Command
files}.

@item -q | --quiet
@cindex @code{-q}
@cindex @code{--quiet}
``Quiet''.  Do not print the introductory and copyright messages.  These
messages are also suppressed in batch mode.

@item -t | --terminal | --tty @var{tty}
@cindex @code{-t}
@cindex @code{--terminal}
@cindex @code{--tty}
Debugger output usually goes to a terminal rather than @code{STDOUT}
which the debugged program may use. Determination of the tty or
pseudo-tty is normally done automatically. However if you want to
control where the debugger output goes, use this option.

If you want output to go to C<STDOUT>, use C<&1>. Note: the C<&> may
have to be escaped or quoted to avoid shell interpretation with
forking.

@item -x | --eval-command
@cindex @code{-x}
@cindex @code{--eval-command} @var{cmdfile}
execute debugger commands from @var{cmdfile}.
@item -L | --library @var{directory}

@cindex @code{-L}
@cindex @code{--library}
Set directory where debugger files reside to @var{directory}. The
default location is @code{../lib/bashdb} relative to the place that
the bashdb script is located. For example if bashdb is located in
@code{@value{bindir}/bashdb}, the default library location will be
@code{@value{libdir}/bashdb} which may or may not exist. If it doesn't
you'll get an error when you run bashdb. Only if the default location
is incorrect, should you need to use the @code{-L} option.

@item -T | --tempdir @var{directory}
@cindex @code{-T}
@cindex @code{--tempdir}
Set directory to use for writing temporary files.

@end table

@node Quitting the BASH debugger
@section Quitting the BASH debugger

@cindex interrupt
An interrupt (often @kbd{C-c}) does not exit from @value{DBG}, but
rather terminates the action of any @DBG command that is in
progress and returns to @value{DBG} command level.  Inside a debugger
command interpreter, use @code{quit} command (@pxref{Quit, ,Quitting
the BASH debugger}).

There way to terminate the debugger is to use the @code{kill}
command. This does more forceful @code{kill -9}. It can be used in
cases where @code{quit} doesn't work.

@node Calling from Program
@section Calling the BASH debugger from inside your program
Running a program from the debugger adds a bit of overhead and slows
down your program quite a bit. Addressing this better would mean some
serious changes to @value{BASH} internals, and judging from experience
in other languages there still the slowdown is still noticeable.  If
you have a @code{configure} script generated by autoconf, and you want
to stop in the middle of the script, it can take quite a while.

Furthermore, by necessity, debuggers change the operation of the
program they are debugging. And this can lead to unexpected and
unwanted differences. It has happened so often that the term
``Heisenbugs'' (see @url{http://en.wikipedia.org/wiki/Heisenbug}) was
coined to describe the situation where the addition of the use of a
debugger (among other possibilities) changes behavior of the program
so that the bug doesn't manifest itself anymore.

There is another way to get into the debugger aside from calling
@emph{bashdb} from the outset, and this adds no overhead or slowdown
until you reach the point at which you want to start
debugging. However for this method you must change the script. Because
the debugger isn't involved before the first call, there is no
overhead; the script will run at the same speed as if there were no
debugger up to the point where it is first invoked.
@menu
* Debugging a Running Shell Script::
* Program-Controlled Line Tracing::
@end menu
@node Debugging a Running Shell Script
@subsection Debugging a Running Shell Script
In this section we'll show how to modify your script so that it enters
the debugger when you send it a signal, and then we will show how you
can call the debugger directly.

In either case, you'll need to modify the script to load some the
debugger code.  The name of file to load is @code{bashdb-trace} and it
is located in the directory where the other bash debugger files
live. For example on GNU/Linux if it is in directory
@code{/usr/local/share/bashdb}, you would first add to a @value{BASH}
script the line:

@smallexample
    source /usr/local/share/bashdb/bashdb-trace
@end smallexample

Although I said that running under the debugger adds overhead which
slows down you program, the above command in of itself will @emph{not}
cause any slowdown. If possible, it's best to put this somewhere in
the main-line code rather than in a function or in a subshell. If it
is put in a function of subshell and you step outside of that,
some of the global variables set up in @code{bashdb-trace} may be
lost. One the other hand if you know your debugging will be confined
to just the scope of the @code{source} command there is no problem.

Here's a complete example. In file @file{debugit.sh}
@smallexample
# This is my extra debug hook
  source @emph{/usr/share/bashdb/bashdb-trace} # adjust location

  echo $$
  while : ; do
        date=$(date)
        echo "$date"
        sleep 2
  done
@end smallexample
Now run:
@smallexample
  $ @b{bash ./debugit.sh}
  Bourne-Again Shell Debugger, release bash-3.1-0.08
  Copyright 2002, 2003, 2004, 2006 Rocky Bernstein
  This is free software, covered by the GNU General Public License, and you are
  welcome to change it and/or distribute copies of it under certain conditions.

  9435
  Thu Jun 19 02:43:06 EDT 2008
  Thu Jun 19 02:43:08 EDT 2008
@end smallexample

Sent it an "interrupt" signal
@smallexample
  @b{kill -INT 9435}
@end smallexample

And back to the running program:

@smallexample
  Program received signal SIGINT (2)...
  ->0 in file `./debugit.sh' at line 251  # not sure where 251 came from!
  ##1 main() called from file `./debugit.sh' at line 0
  bashdb<0> where
  ->0 in file `./debugit.sh' at line 9    # but this line number is now right
  ##1 main() called from file `./debugit.sh' at line 0
  bashdb<1> @b{list 1}
    1:   # Set up some interrupt handlers to go into the debugger
    2:   source /usr/share/bashdb/bashdb-trace
    3:
    4:   echo $$
    5:   while : ; do
    6:   date=$(date)
    7:   echo "$date"
    8:   sleep 2
    9:==>done
  bashdb<2> @b{step}
  (./debugit.sh:5):
  5:      while : ; do
  bashdb<3> @b{step}
  (./debugit.sh:6):
  6:      date=$(date)
  bashdb<4> @b{continue -}
@end smallexample
The command @code{continue -} not only continues execution but it
removes the debug trap allowing the program to run at full speed. It
is suitable only if there are no breakpoints that you care to stop at.

By default, @code{bashdb-trace} sets up a handler for the @samp{INT}
exception. If you down't want this or you want enter the debugger on a
different signal to be use, @code{_Dbg_handler}. With this function
you can specify whether to show a call stack, stop (enter the
debugger) and/or print an indication that the a signal was seen.

Here are some examples:
@smallexample
    _Dbg_handler INT print showstack nostop  # this is the default
    _Dbg_handler INT                         # same thing
    _Dbg_hander                              # same thing
    _Dbg_handler HUP print stop              # stop in debugger when getting
@end smallexample

@subsubsection Explicit Debugging Calls.
As we saw in the last section @code{bashdb-trace} installs some signal
handlers. However you can make an explicit call to the debugger
@smallexample
     _Dbg_debugger
@end smallexample

Let's show an example of that. We'll even do it under a condition:
@smallexample
  for ((i=1; i<=10; i++)) ;
        (( 5 == i )) && @{ _Dbg_debugger @}
        date=$(date)
        echo "$date"
        sleep 2
  done
@end smallexample

The debugger will be called on the 5th iteration of this loop, when
@code{i} has the value 5.

You can also supply the number of statements to skip and the options to
@code{_Dbg_debugger} just as you would to the debugger itself. All of
the options listed in @ref{Options for the bashdb script} can be used
with the exception of @code{-c} (run a command) and of course you
don't supply the name of a @value{BASH} script.

For example to stop at the next line and suppress the banner you could
use @code{_Dbg_debugger 1 -q} in the above example.

@node Program-Controlled Line Tracing
@subsection Program-Controlled Line Tracing

You can also turn on and off line tracing. Here's an example

@smallexample
  source @emph{path-to-program}/bashdb-trace # modify location
   ...
  _Dbg_linetrace_on
  for i in `seq 10` ; do
     echo $i
  done
  _Dbg_linetrace_off
   _Dbg_QUIT_ON_QUIT=1
@end smallexample

The @code{_Dbg_QUIT_ON_QUIT}  variable make sure the program doesn't
stay inside the debugger after it quits. It can also be set earlier in
the program.

Again @code{<path-to-program>} is whatever path needed to located
@code{<bashdb-trace>}. For example it might be @code{</usr/local/share>}
on some GNU/Linux installations.

@node Running
@chapter Script Setup inside the BASH Debugger

@menu
* Starting::                    Starting your script
* Command Files::               Command files
* Arguments::                   Your script's arguments
* Input/Output::                Your script's input and output
* Script/Debugger Interaction::   Keeping out of each other's harm
@end menu

@need 2000
@node Starting
@section Starting your script
@cindex starting
@cindex running

After invoking the debugger you should be on the first stoppable line
of your program to be debugged. At this point you can issue debugger
commands to set breakpoints (@pxref{Set Breaks, ,Setting
breakpoints}), or watchpoints (@pxref{Set Watchpoints, ,Setting
watchpoints}), or start continue the execution of the program
(@pxref{Resuming Execution, ,Resuming Execution}).

@table @code
@kindex restart @ovar{args}
@kindex run @r{(@code{restart})}
@kindex R @r{(@code{restart})}
@item restart @ovar{args}
@itemx run @ovar{args}
@itemx R @ovar{args}
Use the @code{restart} command to restart your script under
@value{DBG}. Without any arguments, the script name and parameters
from the last invocation are used. @value{dBGP} tries to maintain the
settings, watchpoints, breakpoints, actions and so on. Internally it
uses line numbers and filenames to record he position of interesting
places in your program; so if your program changes some or all of
these numbers may be off. Environment variable
@code{DBG_RESTART_FILE} is and a temporary file are used to signal
a restart, so you shouldn't uset @code{DBG_RESTART_FILE} (or any
environment variable starting with @code{BASHDB_}.

@end table

@node Command Files
@section Command files

@cindex command files
A command file for @DBG is a file of lines that are @DBG
commands.  Comments (lines starting with @kbd{#}) may also be included.
An empty line in a command file does nothing; it does not mean to repeat
the last command, as it would from the terminal.

@cindex init file
@cindex @file{.bashdbinit}
@cindex @file{bashdb.ini}
When you start @value{DBG}, it automatically executes commands from its
@dfn{init files}, normally called @file{.bashdbinit}@footnote{The DJGPP
port of @DBG uses the name @file{bashdb.ini} instead, due to the
limitations of file names imposed by DOS filesystems.}.
During startup, @DBG does the following:

@enumerate
@item
Reads the init file (if any) in your home directory@footnote{On
DOS/Windows systems, the home directory is the one pointed to by the
@code{HOME} environment variable.}.

@item
Processes command line options and operands.

@item
Reads the init file (if any) in the current working directory.

@item
Reads command files specified by the @samp{-x} option.
@end enumerate

The init file in your home directory can set options (such as @samp{set
complaints}) that affect subsequent processing of command line options
and operands.  Init files are not executed if you use the @samp{-x}
option (@pxref{Options for the bashdb script, ,bashdb script options}).

@cindex init file name
On some configurations of @value{DBG}, the init file is known by a
different name (these are typically environments where a specialized
form of @DBG may need to coexist with other forms, hence a
different name for the specialized version's init file).  These are the
environments with special init file names:

You can also request the execution of a command file with the
@code{source} command:

@table @code
@kindex source
@item source @var{filename}
Execute the command file @var{filename}.
@end table

The lines in a command file are executed sequentially.  They are not
printed as they are executed.  If there is an error, execution
proceeds to the next command in the file.

@node Arguments
@section Your script's arguments

@cindex arguments (to your script)
The arguments to your script can be specified by the arguments of the
@code{restart} command.
They are passed to a shell, which expands wild-card characters and
performs redirection of I/O, and thence to your script.

@code{restart} with no arguments uses the same arguments used by the previous
@code{restart}, or those set by the @code{set args} command..

@table @code
@kindex set args
@item set args
Specify the arguments to be used if your program is rerun. If
@code{set args} has no arguments, @code{restart} executes your program
with no arguments.  Once you have run your program with arguments,
using @code{set args} before the next @code{restart} is the only way to run
it again without arguments.

@kindex show args
@item show args
Show the arguments to give your program when it is started.
@end table

@node Input/Output
@section Your script's input and output

@cindex redirection
@cindex I/O
@cindex terminal
By default, the script you run under the @acronym{BASH} debugger does
input and output to the same terminal that @acronym{BASH} uses.
Before running the script to be debugged, the debugger records the tty
that was in effect. All of its output is then written to that.
However you can change this when using the @samp{bashdb} script using
the @samp{-t} option.


@table @code
@kindex info terminal
@item info terminal
Displays information recorded by @DBG about the terminal modes your
program is using.
@end table

@kindex tty
@cindex controlling terminal
Another way to specify where your script should do input and output is
with the @code{tty} command.  This command accepts a file name as
argument, and causes this file to be the default for future @code{restart}
commands.  It also resets the controlling terminal for the child
process, for future @code{restart} commands.  For example,

@example
tty /dev/ttyb
@end example

@noindent
directs that processes started with subsequent @code{restart} commands
default to do input and output on the terminal @file{/dev/ttyb} and have
that as their controlling terminal.

An explicit redirection in @code{restart} overrides the @code{tty} command's
effect on the input/output device, but not its effect on the controlling
terminal.

When you use the @code{tty} command or redirect input in the @code{restart}
command, only the input @emph{for your script} is affected.  The input
for @DBG still comes from your terminal.

@node Script/Debugger Interaction
@section Script/Debugger Interaction

@value{dBGP} and your program live in the same variable space so to
speak. @acronym{BASH} does not have a notion of module scoping or
lexical hiding (yet) as is found in modern programming languages and
in modern versions of the Korn shell. This then imposes some
additional care and awareness.

Most of the variables and functions used inside @DBG start
@code{_Dbg_}, so please don't use variables or functions with these
names in your program.

@emph{Note: there are some other variables that begin with just an
underscore (@code{_}); over time these will be phased out. But until
then, avoid those or consult what is used by the debugger. Run
@samp{bashdb --debugger -c "declare -p"} to list all the variables in
use including those used by the debugger.}

A number of environment variables are also reserved for use; these
start with @code{DBG_}. For example: @env{DBG_INPUT},
@env{DBG_LEVEL} and, @env{_Dbg_QUIT_ON_QUIT} (@pxref{Debug,
,Debug}), @env{DBG_RESTART_FILE} (@pxref{Starting, ,Starting}), to
name a few.  Finally, there are some @acronym{BASH} environment
dynamic variables and these start with @env{BASH_}. For example
@env{BASH_SUBSHELL} (@pxref{Debug, ,Debug}), @env{BASH_COMMAND}
(@pxref{Command Display, ,Command Display}), @env{BASH_LINENO}, and
@env{BASH_SOURCE} to name a few.

Inside the debugger some variables may be redefined. In particular
@code{IFS} and @code{PS4}, and various dollar variables @code{$?},
@code{$1}, @code{$2}, etc. The values before entering the debugger are
saved and those variables have their old values restored when leaving
the debugger. However you may notice these difference in various
debugger commands. For example @code{examine PS4} might not return the
same value as @code{eval declare -p PS4}. The former is picking the debugger
value while the @code{eval} is careful to restore the value to what
it was before entering the debugger.

In order to do its work @value{dBGP} sets up a @code{DEBUG}
trap. Consequently a script shouldn't reset this or the debugger will
lose control. @value{dBGP} also sets up an @code{EXIT} handler so that
it can gain control after the script finishes. Another signal
intercepted is the an interrupt or @code{INT} signal. For more
information about signal handling, @pxref{Signals, ,Signals}

@node Debugger Command Reference
@chapter BASH Debugger Command Reference

You can abbreviate the long name of @DBG command to the first
few letters of the command name, if that abbreviation is unambiguous;
and you can repeat the @code{next} or @code{step} commands by typing
just @key{RET}. Some commands which require a parameter, such as
@code{print} remember the argument that was given to them.

@menu
* Command Syntax::       How to give commands to the BASH debugger
* Help::                 How to ask for help (help)
* Quit::                 Leaving the debugger (quit, kill)
* Stopping::             Stopping and continuing (break, watch, step, cont...)
* Stack::                Examining the stack frame (where, up, down, frame)
* List::                 Printing source files (list)
* Edit::                 Editing source files (edit)
* Search::               Searching source files (/pat/ ?pat?)
* Data::                 Examining data (print, examine, info variables)
* Auto Display::         Executing expressions on stop (display, undisplay)
* Evaluation/Execution:: Arbitrary execution (eval, eval? shell)
* Interfacing to the OS:: Interfacing to the OS (cd, pwd)
* Information and Settings::  Status and Debugger settings (info, show)
* Controlling bashdb::   Controlling bashdb (annotate, file, prompt, history...)
@end menu

@node Command Syntax
@section Command syntax

A @acronym{BASH} debugger command is a single line of input.  There is
no limit on how long it can be.  It starts with a command name, which
is followed by arguments whose meaning depends on the command name.
For example, the command @code{step} accepts an argument which is the
number of times to step, as in @samp{step 5}.  You can also use the
@code{step} command with no arguments.  Some commands do not allow any
arguments.

@cindex repeating next/step commands
@kindex RET @r{(repeat last command)}
A blank line as input to @DBG (typing just @key{RET}) means to
repeat the previous next or step command.

@kindex # @r{(a comment)}
@cindex comment
Any text from a @kbd{#} to the end of the line is a comment; it does
nothing.  This is useful mainly in command files (@pxref{Command
Files,,Command files}).

@node Help
@section Getting help (@samp{help})
@cindex online documentation

Once inside the @acronym{BASH} debugger, you can always ask it for
information on its commands, using the command @code{help}.

@table @code
@kindex h @r{(@code{help})}
@item help
@itemx h
You can use @code{help} (abbreviated @code{h}) with no arguments to
display a short list of named classes of commands:
@end table

@flushleft
@smallexample
bashdb<0> @b{help}
Available commands:
  action     condition  edit     frame    load     run     source  unalias
  alias      continue   enable   handle   next     search  step    undisplay
  backtrace  debug      eval     help     print    set     step-   untrace
  break      delete     examine  history  pwd      shell   step+   up
  clear      disable    export   info     quit     show    tbreak  watch
  commands   display    file     kill     return   signal  trace   watche
  complete   down       finish   list     reverse  skip    tty

Readline command line editing (emacs/vi mode) is available.
Type "help" followed by command name for full documentation.
@end smallexample
@end flushleft
@c the above line break eliminates huge line overfull...

@table @code
@item help @var{command}
With a command name as @code{help} argument, the @acronym{BASH}
debugger displays short information on how to use that command.

@example
bashdb<0> @b{help list}
list [START|.|FN] [COUNT] -- List lines of a script.

START is the starting line or dot (.) for current line. Subsequent
list commands continue from the last line listed. If a function name
is given list the text of the function.

If COUNT is omitted, use the setting LISTSIZE. Use "set listsize" to
change this setting.

Aliases for list: l
@end example

In addition to @code{help}, you can use the debugger command
@code{info} to inquire about the state of your script, or the state of
@DBG itself.  The listings under @code{info} in the Index
point to all the sub-commands.  @xref{Command Index}.
@end table

@c @group
@table @code
@kindex info
@kindex i @r{(@code{info})}
@item info
This command (abbreviated @code{i}) is for describing the state of
your program.  For example, you can list the arguments given to your
script with @code{info args}, or list the breakpoints you have set
with @code{info breakpoints}.  You can get a complete list of the
@code{info} sub-commands with @w{@code{help info}}.

@example
bashdb<0> @b{help info}
List of info subcommands:

info args -- Argument variables (e.g. $1, $2, ...) of the current stack frame.
info breakpoints -- Status of user-settable breakpoints
info display -- Show all display expressions
info files -- Source files in the program
info functions -- All function names
info line -- list current line number and and file name
info program -- Execution status of the program.
info signals -- What debugger does when program gets various signals
info source -- Information about the current source file
info stack -- Backtrace of the stack
info terminal -- Print terminal device
info variables -- All global and static variable names
info warranty -- Various kinds of warranty you do not have

Aliases for info: i
bashdb<1> @b{info source}
Current script file is parm.sh
Located in /tmp/parm.sh
Contains 34 lines.
@end example
@end table


@node Quit
@section Quitting the BASH debugger (@samp{quit}, @samp{kill})

@table @code
@kindex quit @r{[}@var{expression} @ovar{subshell-levels}@r{]}
@kindex q @r{(@code{quit})}
@item quit @ovar{expression}
@item quit @r{[}@var{expression} @ovar{subshell-levels}@r{]}
@itemx q

To exit @value{DBG}, use the @code{quit} command (abbreviated
@code{q}), or type an end-of-file character (usually @kbd{C-d}).  If
you do not supply @var{expression}, @DBG will try to terminate
normally or with exit code 0. Otherwise it will terminate using the
result of @var{expression} as the exit code.

A simple @code{quit} tries to terminate all nested subshells that may
be in effect.  If you are nested a subshell, this is normally
indicated in a debugger prompt by the number of parentheses that the
history number is inside --- no parenthesis means there is no subshell
in effect. The dynamic variable @env{BASH_SUBSHELL} also contains the
number of subshells in effect.

If you want only to terminate some number of subshells but not all of
them, you can give a count of the number of subshells to leave after
the return-code expression. To leave just one level of subshell
@code{return} does almost the same thing. (See @pxref{Returning,
,Returning}) There is a subtle difference between the two though:
@code{return} will leave you at the beginning of the next statement
while @code{quit} may leave you at the place the subshell was invoked
which may be in the middle of another command such as an assignment
statement or condition test.

If the environment variable @code{_Dbg_QUIT_ON_QUIT} is set, when the
program terminates, the debugger will also terminate too. This may be
useful if you are debugging a script which calls another script and
you want this inner script just to return to the outer script.

@item kill
@kindex k @r{(@code{kill})}
@itemx k
In situations where @code{quit} doesn't work we provide an alternative
and more forceful quit command: @code{kill}. This sends to the OS
non-maskable KILL signal with the debugger process number. No cleanup
of temporary files is done by the program.
@end table

@node Stopping
@section Stopping and Resuming Execution

One important use of a debugger is to stop your program @emph{before} it
terminates so that if your script might run into trouble, you can
investigate and find out why. However should your script accidentally
continue to termination, @DBG has arranged for it not to leave the
debugger without your explicit instruction. That way, you can restart
the program using the same command arguments.

Inside @value{DBG}, your script may stop for any of several reasons,
such as a signal, a breakpoint, or reaching a new line after a
debugger command such as @code{step}.  You may then examine and
change variables, set new breakpoints or remove old ones, and then
continue execution.

@menu
* Breakpoints::          Breakpoints, watchpoints (break, tbreak, watch, watche, clear)
* Resuming Execution::   Resuming execution (continue, step, next, skip, finish, return, debug)
* Signals::              Signals
@end menu

@node Breakpoints
@subsection Breakpoints, watchpoints (@samp{break}, @samp{tbreak}, @samp{watch}, @samp{watche}...)

@cindex breakpoints
A @dfn{breakpoint} makes your script stop whenever a certain point in
the program is reached.  For each breakpoint, you can add conditions to
control in finer detail whether your script stops.

You specify the place where your script should stop with the @code{break}
command and its variants (@pxref{Set Breaks, ,Setting
breakpoints}). These commands allow own to specify the location by
line number and file name or function name.

@cindex watchpoints
@cindex breakpoint on variable modification
A @dfn{watchpoint} is a special breakpoint that stops your script when
the value of an expression changes.  There is a different command to
set watchpoints (@pxref{Set Watchpoints, ,Setting watchpoints}).

But aside from that, you can manage a watchpoint like any other
breakpoint: you delete enable, and disable both breakpoints and
watchpoints using the same commands.

You can arrange to have values from your program displayed automatically
whenever @value{BASH} stops at a breakpoint.  @xref{Auto Display,,
Automatic display}.

@cindex breakpoint numbers
@cindex numbers for breakpoints
@value{dBGP} assigns a number to each breakpoint when you create it;
these numbers are successive integers starting with one.  In many of
the commands for controlling various features of breakpoints you use
the breakpoint number to say which breakpoint you want to change.
Each breakpoint may be @dfn{enabled} or @dfn{disabled}; if disabled,
it has no effect on your script until you enable it again.

@cindex watchpoints numbers
@cindex numbers for watchpoints
Watchpoint numbers however are distinguished from breakpoint numbers by
virtue of their being suffixed with the either an upper- or lower-case
`W'.  For example, to enable breakpoint entry 0 along with watchpoint
entry 1 you would write @samp{enable 1 2w}, the ``2w'' refers to the
watchpoint; ``2W'' would work just as well.

@ifset FINISHED
@cindex breakpoint ranges
@cindex ranges of breakpoints
Some @DBG commands accept a range of breakpoints on which to
operate.  A breakpoint range is either a single breakpoint number, like
@samp{5}, or two such numbers, in increasing order, separated by a
hyphen, like @samp{5-7}.  When a breakpoint range is given to a command,
all breakpoint in that range are operated on.
@end ifset

@menu
* Set Breaks::                      Setting breakpoints (break, tbreak)
* Set Watchpoints::                 Setting watchpoints (watch, watche)
* Break Commands::                  Breakpoint command lists (command)
* Delete Breaks::                   Deleting breakpoints (delete, clear)
* Disabling::                       Disabling breakpoints (disable, enable)
* Conditions::                      Break conditions (condition)
@end menu

@node Set Breaks
@subsubsection Setting breakpoints (@samp{break} @samp{tbreak})

@kindex break
@kindex b @r{(@code{break})}
@cindex latest breakpoint
Breakpoints are set with the @code{break} command (abbreviated
@code{b}).

@table @code
@item break @var{function}
Set a breakpoint at entry to function @var{function}.

@item break @var{linenum}
Set a breakpoint at line @var{linenum} in the current source file.
The current source file is the last file whose source text was printed.
The breakpoint will stop your script just before it executes any of the
code on that line.

@item break @var{filename}:@var{linenum}
Set a breakpoint at line @var{linenum} in source file @var{filename};
@var{filename} has to be one of the files previously read in and has
to be specified exactly as the name used when read in. For a list of
read-in files, use the @samp{info files} command.

@ifset FINISHED
@item break
When called without any arguments, @code{break} sets a breakpoint at
the next instruction to be executed in the selected stack frame
(@pxref{Stack, ,Examining the Stack Frame}).  In any selected frame but the
innermost, this makes your script stop as soon as control returns to
that frame.  If you use @code{break} without an argument in the
innermost frame, @DBG stops the next time it reaches the
current location; this may be useful inside loops.
@end ifset

@item break @dots{} if @var{cond}
Set a breakpoint with condition @var{cond}; evaluate the expression
@var{cond} each time the breakpoint is reached, and stop only if the
value is nonzero---that is, if @var{cond} evaluates as true. The
expression is evaluated via the @code{let} built-in function.
@samp{@dots{}} stands for one of the possible arguments described
above (or no argument) specifying where to break. The word ``if'' is
often optional and is necessary only @samp{@dots{}} is
omitted. @xref{Conditions, ,Break conditions}, for more information on
breakpoint conditions.

Examples:
@example
bashdb<0> @b{break fn1}
Breakpoint 1 set in file parm.sh, line 3.
bashdb<1> @b{break 28}
Breakpoint 2 set in file parm.sh, line 28.
bashdb<2> @b{break parm.sh:29}
Breakpoint 3 set in file parm.sh, line 29.
bashdb<3> @b{break 28 if x==5}
Breakpoint 4 set in file parm.sh, line 28.
@end example

@kindex tbreak
@item tbreak @var{args}
Set a breakpoint enabled only for one stop.  @var{args} are the
same as for the @code{break} command, and the breakpoint is set in the same
way, but the breakpoint is automatically deleted after the first time your
program stops there.  @xref{Disabling, ,Disabling breakpoints}.

@kindex info breakpoints
@cindex @code{$_} and @code{info breakpoints}
@item info breakpoints @ovar{n}
@itemx info break @ovar{n}
@itemx info watchpoints @ovar{n}
Print a table of all breakpoints, watchpoints set and not deleted,
with the following columns for each breakpoint:

@table @emph
@item Breakpoint Numbers (@samp{Num})
@item Enabled or Disabled (@samp{Enb})
Enabled breakpoints are marked with @samp{1}.  @samp{0} marks breakpoints
that are disabled (not enabled).
@item Count
The number of times that breakpoint or watchpoint has been hit.
@item File and Line (@samp{file:line})
The filename and line number inside that file where of breakpoint in
the script. The file and line are separated with a colon.
@item Condition
A condition (an arithmetic expression) which when true causes the
breakpoint to take effect.
@end table

@noindent
If a breakpoint is conditional, @code{info break} shows the condition on
the line following the affected breakpoint; breakpoint commands, if any,
are listed after that.

@noindent
@code{info break} displays a count of the number of times the breakpoint
has been hit.

@code{info break} with a breakpoint number @var{n} as argument lists
only that breakpoint.

Examples:
@example
bashdb<4> @b{info break}
Breakpoints at following places:
Num Type       Disp Enb What
1   breakpoint keep y   parm.sh:3
2   breakpoint keep y   parm.sh:28
3   breakpoint keep y   parm.sh:29
4   breakpoint keep y   parm.sh:28
No watch expressions have been set.
bashdb<5> @b{info break 4}
Num Type       Disp Enb What
4   breakpoint keep y   parm.sh:28
No watch expressions have been set.
@end example
@end table


@ifset FINISHED
This is especially useful in conjunction with the
@code{ignore} command.  You can ignore a large number of breakpoint
hits, look at the breakpoint info to see how many times the breakpoint
was hit, and then run again, ignoring one less than that number.  This
will get you quickly to the last hit of that breakpoint.
@end ifset

@DBG allows you to set any number of breakpoints at the same place in
your script.  There is nothing silly or meaningless about this.  When
the breakpoints are conditional, this is even useful
(@pxref{Conditions, ,Break conditions}).

@node Set Watchpoints
@subsubsection Setting watchpoints (@samp{watch}, @samp{watche})

@cindex setting watchpoints
You can use a watchpoint to stop execution whenever the value of an
expression changes, without having to predict a particular place where
this may happen. As with the @code{print} (@pxref{Data,,Examining
Data}), the idiosyncrasies of a @acronym{BASH} or any POSIX shell
derivative suggest using two commands. The @code{watch} command is
just for a single variables; the @code{watche} command uses the
builtin ``let'' command to evaluate an expression. If the variable you
are tracking can take a string value, issuing something like
@samp{watch foo} will not have the desired effect---any string
assignment to @code{foo} will have a value 0 when it is assigned via
``let.''

@table @code
@kindex watch
@item watch @var{var}
Set a watchpoint for a variable.  @DBG will break when the
value of @var{var} changes. In this command do not add a leading
dollar symbol to @var{var}.

@item watche @var{expr}
Set a watchpoint for an expression via the builtin ``let'' command.
@DBG will break when @var{expr} is written into by the program
and its value changes. Not that this may not work for tracking
arbitrary string value changes. For that use @code{watch} described
earlier.
@end table

@node Break Commands
@subsubsection Breakpoint command lists (@samp{commands})

@table @code
@kindex commands
@kindex end
@item commands @r{[}@var{bnum}@r{]}
@itemx @dots{} @var{command-list} @dots{}
@itemx end
Specify a list of commands for breakpoint number @var{bnum}.  The commands
themselves appear on the following lines.  Type a line containing just
@code{end} to terminate the commands.

To remove all commands from a breakpoint, type @code{commands} and
follow it immediately with @code{end}; that is, give no commands.

With no @var{bnum} argument, @code{commands} refers to the last
breakpoint, watchpoint, or catchpoint set (not to the breakpoint most
recently encountered).
@end table

Pressing @key{RET} as a means of repeating the last debugger command is
disabled within a @var{command-list}.

You can use breakpoint commands to start your program up again.  Simply
use the @code{continue} command, or @code{step}, or any other command
that resumes execution.

Any other commands in the command list, after a command that resumes
execution, are ignored.  This is because any time you resume execution
(even with a simple @code{next} or @code{step}), you may encounter
another breakpoint---which could have its own command list, leading to
ambiguities about which list to execute.

@kindex silent
If the first command you specify in a command list is @code{silent}, the
usual message about stopping at a breakpoint is not printed.  This may
be desirable for breakpoints that are to print a specific message and
then continue.  If none of the remaining commands print anything, you
see no sign that the breakpoint was reached.  @code{silent} is
meaningful only at the beginning of a breakpoint command list.

The commands @code{echo}, @code{output}, and @code{printf} allow you to
print precisely controlled output, and are often useful in silent
breakpoints.

For example, here is how you could use breakpoint commands to print the
value of @code{x} at entry to @code{foo} whenever @code{x} is positive.

@smallexample
break foo if x>0
commands
silent
printf "x is %d\n",x
cont
end
@end smallexample

One application for breakpoint commands is to compensate for one bug so
you can test for another.  Put a breakpoint just after the erroneous line
of code, give it a condition to detect the case in which something
erroneous has been done, and give it commands to assign correct values
to any variables that need them.  End with the @code{continue} command
so that your program does not stop, and start with the @code{silent}
command so that no output is produced.  Here is an example:

@smallexample
break 403
commands
silent
set x = y + 4
cont
end
@end smallexample

@node Delete Breaks
@subsubsection Deleting breakpoints (@samp{clear}, @samp{delete})

@cindex clearing breakpoints, watchpoints
@cindex deleting breakpoints, watchpoints
It may desirable to eliminate a breakpoint or watchpoint once it
has done its job and you no longer want your script to stop there.
This is called @dfn{deleting} the breakpoint.  A breakpoint that has
been deleted no longer exists; it is forgotten.

With the @code{clear} command you can delete breakpoints according to
where they are in your script.  With the @code{delete} command you can
delete individual breakpoints, or watchpoints by specifying their
breakpoint numbers. @emph{Note: as described below under the ``clear''
command, ``d'' is an alias for ``clear'', not ``delete''. }

It is not necessary to delete a breakpoint to proceed past it.  @DBG
automatically ignores breakpoints on the first instruction to be executed
when you continue execution.

@table @code
@kindex clear
@kindex d @r{(@code{clear})}
@item clear
Delete any breakpoints at the next instruction to be executed in the
selected stack frame (@pxref{Selection, ,Selecting a frame}).  When
the innermost frame is selected, this is a good way to delete a
breakpoint where your script just stopped.

It may seem odd that we have an alias ``d'' for ``clear.'' It so
happens that Perl's debugger use ``d'' for its delete command and the
delete concept in Perl's debugger corresponds to ``clear'' in
GDB. (Perl doesn't have a notion of breakpoint entry numbers). So in
order to be compatible with both debugger interfaces, ``d'' is used as
an alias for ``clear.'' Clear?

@item clear @var{function}
@itemx clear @var{filename}:@var{function}
Delete any breakpoints set at entry to the function @var{function}.

@item clear @var{linenum}
@itemx d @var{linenum}
@ifset FINISHED
@itemx clear @var{filename}:@var{linenum}
@end ifset
Delete any breakpoints set at or within the code of the specified line.

@cindex delete breakpoints
@kindex delete
@kindex de @r{(@code{delete})}
@item delete @ovar{breakpoints}
Delete the breakpoints, watchpoints specified as arguments.

If no argument is specified, delete all breakpoints (@DBG asks
confirmation, unless you have @code{set confirm off}).  You can
abbreviate this command as @code{de}.


Note that for compatibility with Perl's debugger, @code{d} means
something else: @code{clear}.

@end table

@node Disabling
@subsubsection Disabling breakpoints (@samp{disable}, @samp{enable})

Rather than deleting a breakpoint or watchpoint, you might
prefer to @dfn{disable} it.  This makes the breakpoint inoperative as if
it had been deleted, but remembers the information on the breakpoint so
that you can @dfn{enable} it again later.

You disable and enable breakpoints, watchpoints, and catchpoints with
the @code{enable} and @code{disable} commands, optionally specifying one
or more breakpoint numbers as arguments.  Use @code{info break} or
@code{info watch} to print a list of breakpoints, watchpoints, and
catchpoints if you do not know which numbers to use.

A breakpoint, watchpoint, or catchpoint can have any of four different
states of enablement:

@itemize @bullet
@item
Enabled.  The breakpoint stops your program.  A breakpoint set
with the @code{break} command starts out in this state.
@item
Disabled.  The breakpoint has no effect on your program.
@item
Enabled once.  The breakpoint stops your program, but then becomes
disabled.
@item
Enabled for deletion.  The breakpoint stops your program, but
immediately after it does so it is deleted permanently.  A breakpoint
set with the @code{tbreak} command starts out in this state.
@end itemize

You can use the following commands to enable or disable breakpoints,
watchpoints, and catchpoints:

@table @code
@kindex disable breakpoints
@kindex disable
@kindex dis @r{(@code{disable})}
@item disable @ovar{breakpoints}
Disable the specified breakpoints---or all breakpoints, if none are
listed.  A disabled breakpoint has no effect but is not forgotten.  All
options such as ignore-counts, conditions and commands are remembered in
case the breakpoint is enabled again later.  You may abbreviate
@code{disable} as @code{dis}.

@kindex enable breakpoints
@kindex enable
@item enable @ovar{breakpoints}
Enable the specified breakpoints (or all defined breakpoints).  They
become effective once again in stopping your program.
@end table

@c FIXME: I think the following ``Except for [...] @code{tbreak}'' is
@c confusing: tbreak is also initially enabled.
Except for a breakpoint set with @code{tbreak} (@pxref{Set Breaks,
,Setting breakpoints}), breakpoints that you set are initially enabled;
subsequently, they become disabled or enabled only when you use one of
the commands above.  (The command @code{until} can set and delete a
breakpoint of its own, but it does not change the state of your other
breakpoints; see @ref{Resuming Execution, ,Resuming Execution}.)

@node Conditions
@subsubsection Break conditions (@samp{condition})
@cindex conditional breakpoints
@cindex breakpoint conditions

The simplest sort of breakpoint breaks every time your script reaches
a specified place.  You can also specify a @dfn{condition} for a
breakpoint.  A condition is just a @acronym{BASH} expression.

Break conditions can be specified when a breakpoint is set, by using
@samp{if} in the arguments to the @code{break} command.  @xref{Set
Breaks, ,Setting breakpoints}.  A breakpoint with a condition
evaluates the expression each time your script reaches it, and your
script stops only if the condition is @emph{true}. They can also be
changed at any time with the @code{condition} command.

@cindex one-time breakpoints
There is also a notion of a ``one-time'' breakpoint which gets deleted
as soon as it is hit, so that that breakpoint is executed once only.

Conditions are also accepted for watchpoints; you may not need them,
since a watchpoint is inspecting the value of an expression anyhow---but
it might be simpler, say, to just set a watchpoint on a variable name,
and specify a condition that tests whether the new value is an interesting
one.


@ifset FINISHED
You can also use the @code{if} keyword with the @code{watch} command.
The @code{catch} command does not recognize the @code{if} keyword;
@code{condition} is the only way to impose a further condition on a
catchpoint.
@end ifset

@table @code
@kindex condition
@item condition @var{bnum} @var{expression}
Specify @var{expression} as the break condition for breakpoint
@var{bnum}.  After you set a condition, breakpoint @var{bnum} stops
your program only if the value of @var{expression} is true (nonzero).

@item condition @var{bnum}
Remove the condition from breakpoint number @var{bnum}.  It becomes
an ordinary unconditional breakpoint.
@end table

@ifset FINISHED
When you use @code{condition}, @DBG checks @var{expression}
immediately for syntactic correctness, and to determine whether
symbols in it have referents in the context of your breakpoint.  If
@var{expression} uses symbols not referenced in the context of the
breakpoint, @DBG prints an error message:

@example
No symbol "foo" in current context.
@end example
@end ifset

@noindent
@acronym{BASH} does
not actually evaluate @var{expression} at the time the @code{condition}
command (or a command that sets a breakpoint with a condition, like
@code{break if @dots{}}) is given, however.

Examples;
@example
condition 1 x>5   # Stop on breakpoint 0 only if x>5 is true.
condition 1       # Change that! Unconditinally stop on breakpoint 1.
@end example

@node Resuming Execution
@subsection Resuming Execution (@samp{step}, @samp{next}, @samp{finish}, @samp{skip}, @samp{continue}, @samp{debug}, @samp{return})

A typical technique for using stepping is to set a breakpoint
(@pxref{Breakpoints, ,Breakpoints; watchpoints}) at the
beginning of the function or the section of your script where a problem
is believed to lie, run your script until it stops at that breakpoint,
and then step through the suspect area, examining the variables that are
interesting, until you see the problem happen.

@cindex stepping
@cindex continuing
@cindex resuming execution
@dfn{Continuing} means resuming program execution until your script
completes normally.  In contrast, @dfn{stepping} means executing just
one more ``step'' of your script, where ``step'' may mean either one
line of source code.  Either when continuing or when stepping,
your script may stop even sooner, due to a breakpoint or a signal.

@menu
* Step::          running the next statement (step)
* Next::          running the next statement skipping over functions (next)
* Finish::        running until the return of a function or ``source'' (finish)
* Skip::          skipping the next statement (skip)
* Continue::      continuing execution (continue)
* Debug::         debugging into another program (debug)
* Returning::     returning
@end menu

@node Step
@subsubsection Step (@samp{step})
@table @code
@kindex step
@kindex s @r{(@code{step})}
@item step@ovar{+|-} @ovar{count}
Continue running your script until control reaches a different source
line, then stop it and return control to @value{DBG}.  An default
alias alias for this is @code{s}.

The @code{step} command only stops at the first instruction of a source
line.  This prevents the multiple stops that could otherwise occur in
@code{switch} statements, @code{for} loops, etc.  @code{step} continues
to stop if a function that has debugging information is called within
the line.  In other words, @code{step} @emph{steps inside} any functions
called within the line.

Sometimes you want to step ensure that the next line is different from
the one you currently are on. To do this, add the @code{+} suffix. And
if you find you want to do this all of the time there is a setting
@code{force} that will have this be the default behavior. On the other
hand if you want to be explicit about not having this behavior even
when @code{force} is in effect add the @code{-} suffix.

With a count, continue running as in @code{step}, but do so
@var{count} times.  If a breakpoint is reached, or a signal not
related to stepping occurs before @var{count} steps, stepping stops
right away.
@end table

@node Next
@subsubsection Next (@samp{next})
@table @code
@kindex next
@kindex n @r{(@code{next})}
@item next @ovar{count}
Continue to the next source line in the current (innermost) stack frame.
This is similar to @code{step}, but function calls that appear within
the line of code are executed without stopping.  Execution stops when
control reaches a different line of code at the original stack level
that was executing when you gave the @code{next} command.  This command
is abbreviated @code{n}.

An argument @var{count} is a repeat count, as for @code{step}.
@end table

@node Finish
@subsubsection Finish (@samp{finish})
@table @code
@kindex finish
@item finish
Continue running until just after function returns.  @emph{Currently,
the line shown on a return is the function header, unless the
@code{return} builtin function is executed in which case it is the
line number of the @code{return} function.}

Contrast this with the @code{return} command (@pxref{Returning,
,Returning from a function}) and the @code{quit} (@pxref{Quitting the
BASH debugger, ,Quitting the BASH debugger}).

@end table

@node Skip
@subsubsection Skip (@samp{skip})
@table @code
@kindex skip
@item skip @ovar{count}
Skip execution of the next source line.
This may be useful if you have an action that ``fixes'' existing code in
the script. The @code{debug} command internally uses the @code{skip} command
to skip over existing non-debugged invocation that was presumably just
run.
@end table

@node Continue
@subsubsection Continue (@samp{continue})
@table @code
@kindex continue
@kindex c @r{(@code{continue})}
@item continue @ovar{- | line-specification}
@itemx c @ovar{line-specification}
Resume program execution, at the address where your script last
stopped; any breakpoints set at that address are bypassed.

The optional argument @var{line-specification} allows you to specify a
location (a line number, function, or filename linenumber combination)
to set a one-time breakpoint which is deleted when that breakpoint is
reached. Should the program stop before that breakpoint is reached, in
a listing of the breakpoints you will see this entry with the
condition 9999 which indicates a one-time breakpoint.

If instead of a line specification you enter @code{-}, debugging will be
turned of after continuing causing the program to run at full speed.
@end table

To resume execution at a different place, you can use @code{return}
(@pxref{Returning, ,Returning from a function}) to go back to the
calling function or sourced script. If you are nested inside a
subshell, @code{quit} with a value for the number of subshells to
exit also functions like a return.

@node Debug
@subsubsection Debug (@samp{debug})
@table @code
@kindex debug
@item debug @ovar{script-name}
Debug into @var{script-name}. If no name is given the current source line
is used. In either case the options are prepended to cause the
debugger to run.

The nesting level of the debugger is saved inside environment variable
@code{_Dbg_DEBUGGER_LEVEL}. The debugger prompt indicates the level of nesting
by enclosing the history in that many nestings of @code{<>} symbols.

@end table

@node Returning
@subsubsection Returning from a function, sourced file, or subshell (@samp{return})

@table @code
@cindex returning from a function, sourced file or subshell
@kindex return
@item return
You can cancel execution of a function call or a subshell with the
@code{return} command.
@end table

The @code{return} command does not resume execution; it leaves the
program stopped in the state that would exist if the function had just
returned.  See also the @code{quit} command (@ref{Quit, ,Quitting the
BASH debugger}). In some situations @code{return} is similar to
@code{quit}: in particular when the script is @emph{not} currently
inside in a function and the number of subshells in effect is 0, or
when a subshell count of 1 is given on the @code{quit} command.

In contrast, the @code{finish} command (@pxref{Finish, ,Finish})
resumes execution until the selected stack frame returns naturally.

@node Signals
@subsection Signals (@samp{handle}, @samp{info handle}, @samp{signal})
@cindex signals

@menu
* handle::        Specify which signals to handle and show what's been set
* signal::        Send a signal to your program
@end menu

A signal is an asynchronous event that can happen in a program.  The
operating system defines the possible kinds of signals, and gives each
kind a name and a number.  For example, in Unix @code{SIGINT} is the
signal a program gets when you type an interrupt character (often
@kbd{C-c}); @code{SIGALRM} occurs when the alarm clock timer goes off
(which happens only if your program has requested an alarm).

Some signal handlers are installed and changed for @value{DBG}'s
normal use: @code{SIGDEBUG} and @code{SIGEXIT}. @code{SIGDEBUG} is
used by the debugger to potentially stop your program before execution
of each statement occurs, and @code{SIGEXIT} is used to catch your
program just before it is set to leave so you have the option of
restarting the program with the same options (and not leave the
debugger) or let the program quit.

Signal handlers that the debugged script might have installed are
saved and called before the corresponding debugger handler. Thus, the
debugged program should work roughly in the same fashion as when it is
not debugged. However there are some call-stack variables which
inevitably will differ. To try to hedge this a little so the behavior
is the same, @value{DBG} will modify arguments to the traps if it
finds one of the call-stack that change as a result of the debugger
being in place. In particular @env{$LINENO} will get replaced with
@env{$@{BASH_LINENO[0]@}}; also @env{$@{BASH_LINENO[0]@}} and
@env{$@{BASH_SOURCE[0]@}} get replaced with
@env{$@{BASH_LINENO[1]@}} and @env{$@{BASH_SOURCE[1]@}}
respectively.

The debugger also installs an interrupt handler @code{SIGINT} so that
errant programs can be interrupted and you can find out where the
program was when you interrupted it.

@cindex fatal signals
Some signals, including @code{SIGALRM}, are a normal part of the
functioning of your program.  Others, such as @code{SIGSEGV}, indicate
errors; these signals are @dfn{fatal} (they kill your program immediately) if the
program has not specified in advance some other way to handle the signal.
@code{SIGINT} does not indicate an error in your program, but it is normally
fatal so it can carry out the purpose of the interrupt: to kill the program.

@acronym{BASH} has the ability to detect any occurrence of a signal in your
program.  You can tell @acronym{BASH} in advance what to do for each kind of
signal.

@cindex handling signals
Normally, @acronym{BASH} is set up to let the non-erroneous signals like
@code{SIGALRM} be silently passed to your program
(so as not to interfere with their role in the program's functioning)
but to stop your program immediately whenever an error signal happens.
You can change these settings with the @code{handle} command.

@node handle
@subsubsection Intercepting Signals (@samp{handle}, @samp{info handle})
@table @code
@kindex handle
@item handle @var{signal} @var{keywords}@dots{}
Change the way @acronym{BASH} handles signal @var{signal}.  @var{signal}
can be the number of a signal or its name (with or without the
@samp{SIG} at the beginning). The @var{keywords} say what change to make.
@kindex info signals
@item info signals
@itemx info handle
Print a table of all the kinds of signals and how @acronym{BASH} has been told to
handle each one.  You can use this to see the signal numbers of all
the defined types of signals.

@code{info handle} is an alias for @code{info signals}.

@end table

@c @group
The keywords allowed by the @code{handle} command can be abbreviated.
Their full names are:

@table @code
@item stop
@acronym{BASH} should stop your program when this signal happens.  This implies
the @code{print} keyword as well.

@item nostop
@acronym{BASH} should not stop your program when this signal happens.  It may
still print a message telling you that the signal has come in.

@item print
@acronym{BASH} should print a message when this signal happens.

@item noprint
@acronym{BASH} should not mention the occurrence of the signal at all.

@item stack
@acronym{BASH} should print a stack trace when this signal happens.

@item nostack
@acronym{BASH} should not print a stack trace when this signal occurs.

@ifset FINISHED
@item pass
@itemx noignore
@acronym{BASH} should allow your program to see this signal; your program
can handle the signal, or else it may terminate if the signal is fatal
and not handled.  @code{pass} and @code{noignore} are synonyms.

@item nopass
@itemx ignore
@acronym{BASH} should not allow your program to see this signal.
@code{nopass} and @code{ignore} are synonyms.
@end ifset
@end table
@c @end group

@ifset FINISHED
When a signal stops your program, the signal is not visible to the
program until you
continue.  Your program sees the signal then, if @code{pass} is in
effect for the signal in question @emph{at that time}.  In other words,
after @acronym{BASH} reports a signal, you can use the @code{handle}
command with @code{pass} or @code{nopass} to control whether your
program sees that signal when you continue.

The default is set to @code{nostop}, @code{noprint}, @code{pass} for
non-erroneous signals such as @code{SIGALRM}, @code{SIGWINCH} and
@code{SIGCHLD}, and to @code{stop}, @code{print}, @code{pass} for the
erroneous signals.
@end ifset

@node signal
@subsubsection Sending your program a signal (@samp{signal})
@table @code
@kindex signal
@item signal @r{@var{signal-name} | @var{signal-number}}
You can use the @code{signal} command send a signal to your
program. Supply either the signal name, e.g.@: @code{SIGINT}, or the
signal number @code{15}.
@end table

@node Stack
@section Examining the Stack Frame (@samp{where}, @samp{frame}, @samp{up}, @samp{down})

When your script has stopped, one thing you'll probably want to know
is where it stopped and some idea of how it got there.

@cindex call stack
Each time your script performs a function call (either as part of a
command substitution or not), or `source's a file, information about
this action is saved.  The call stack then is this a history of the
calls that got you to the point that you are currently stopped at.

@cindex selected frame
One of the stack frames is @dfn{selected} by @DBG and many
@DBG commands refer implicitly to the selected frame.  In
particular, whenever you ask @DBG to list lines without giving
a line number or location the value is found in the selected frame.
There are special @DBG commands to select whichever frame you
are interested in. @xref{Selection, ,Selecting a frame}.

When your program stops, @acronym{BASH} automatically selects the
currently executing frame and describes it briefly, similar to the
@code{frame} command.


@menu
* Frames::                      Stack frames
* Backtrace::                   Backtraces (where)
* Selection::                   Selecting a frame (up, down, frame)

@end menu

@node Frames
@subsection Stack frames

@cindex frame, definition
@cindex stack frame
The call stack is divided up into contiguous pieces called @dfn{stack
frames}, or @dfn{frames} for short; each frame is the data associated
with one call to one function.  The frame contains the line number of
the caller of the function, the source-file name that the line refers
to a function name (which could be the built-in name ``source'')..

@cindex initial frame
@cindex outermost frame
@cindex innermost frame
When your script is started, the stack has only one frame, that of the
function @code{main}.  This is called the @dfn{initial} frame or the
@dfn{outermost} frame.  Each time a function is called, a new frame is
made.  Each time a function returns, the frame for that function invocation
is eliminated.  If a function is recursive, there can be many frames for
the same function.  The frame for the function in which execution is
actually occurring is called the @dfn{innermost} frame.  This is the most
recently created of all the stack frames that still exist.

@cindex frame number
@value{DBG} assigns numbers to all existing stack frames, starting with
zero for the innermost frame, one for the frame that called it,
and so on upward.  These numbers do not really exist in your script;
they are assigned by @value{DBG} to give you a way of designating stack
frames in @value{DBG} commands.

@node Backtrace
@subsection Backtraces (@samp{where})

@cindex backtraces
@cindex tracebacks
@cindex stack traces
A backtrace is essentially the same as the call stack: a summary of
how your script got where it is.  It shows one line per frame, for
many frames, starting with the place that you are stopped at (frame
zero), followed by its caller (frame one), and on up the stack.

@table @code
@kindex backtrace
@kindex bt @r{(@code{backtrace})}
@item backtrace
@itemx bt
@itemx where
@itemx T
Print a backtrace of the entire stack: one line per frame for all
frames in the stack.

@item backtrace @var{n}
@itemx bt @var{n}
@itemx where @var{n}
@itemx T @var{n}
Similar, but print only the innermost @var{n} frames.

@ifset FINISHED
@item backtrace -@var{n}
@itemx bt -@var{n}
@itemx where -@var{n}
@itemx T -@var{n}
Similar, but print only the outermost @var{n} frames.
@end ifset
@end table

@kindex where
The names @code{where} and @code{T} are additional aliases for
@code{backtrace}.

Each line in the backtrace shows the frame number and the function
name, the source file name and line number, as well as the function name.

Here is an example of a backtrace taken a program in the
regression-tests @file{parm.sh}.

@smallexample
@group
% ../bashdb -n -L .. parm.sh
Bourne-Again Shell Debugger, release @value{VERSION}
Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2011 Rocky Bernstein
This is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.

(./parm.sh:21):
21:	fn1 5
bashdb<0> @b{continue fn3}
One-time breakpoint 1 set in file ./parm.sh, line 17.
fn2: testing 1 2 3
(./parm.sh:17):
17:	fn3() @{
bashdb<1> @b{where}
->0 in file `./parm.sh' at line 14
##1 fn3() called from file `./parm.sh' at line 14
##2 fn2("testing 1", "2 3") called from file `parm.sh' at line 5
##3 fn1("0") called from file `parm.sh' at line 9
##4 fn1("1") called from file `parm.sh' at line 9
##5 fn1("2") called from file `parm.sh' at line 9
##6 fn1("3") called from file `parm.sh' at line 9
##7 fn1("4") called from file `parm.sh' at line 9
##8 fn1("5") called from file `parm.sh' at line 21
##9 source("parm.sh") called from file `bashdb' at line 143
##10 main("-n", "-L", "..", "parm.sh") called from file `bashdb' at line 0
@end group
@end smallexample

@noindent
The display for ``frame'' zero isn't a frame at all, although it has
the same information minus a function name; it just indicates that
your script has stopped at the code for line @code{14}
of @code{./parm.sh}.

@node Selection
@subsection Selecting a frame (@samp{up}, @samp{down}, @samp{frame})

Commands for listing source code in your script work on whichever
stack frame is selected at the moment.  Here are the commands for
selecting a stack frame; all of them finish by printing a brief
description of the stack frame just selected.

@table @code
@kindex up @ovar{n}
@item up @ovar{n}
Move @var{n} frames up the stack.  For positive numbers @var{n}, this
advances toward the outermost frame, to higher frame numbers, to
frames that have existed longer.  Using a negative @var{n} is the same
as issuing a @code{down} command of the absolute value of the @var{n}.
Using zero for @var{n} does no frame adjustment, but since the current
position is redisplayed, it may trigger a resynchronization if there is
a front end also watching over things.

@var{n} defaults to one. You may abbreviate @code{up} as @code{u}.

@kindex down
@kindex do @r{(@code{down})}
@item down @ovar{n}
Move @var{n} frames down the stack.  For positive numbers @var{n}, this
advances toward the innermost frame, to lower frame numbers, to frames
that were created more recently.  Using a negative @var{n} is the same
as issuing a @code{up} command of the absolute value of the @var{n}.
Using zero for @var{n} does no frame adjustment, but since the current
position is redisplayed, it may trigger a resynchronization if there is
a front end also watching over things.

@var{n} defaults to one.  You may abbreviate @code{down} as @code{do}.
@end table

All of these commands end by printing two lines of output describing the
frame.  The first line shows the frame number, the function name, the
arguments, and the source file and line number of execution in that
frame.  The second line shows the text of that source line.

@need 100
For example:

@smallexample
@group
bashdb<8> @b{up}
19:	sourced_fn
bashdb<8> @b{T}
##0 in file `./bashtest-sourced' at line 8
->1 sourced_fn() called from file `bashtest-sourced' at line 19
##2 source() called from file `bashdb-test1' at line 23
##3 fn2() called from file `bashdb-test1' at line 33
##4 fn1() called from file `bashdb-test1' at line 42
##5 main() called from file `bashdb-test1' at line 0
@end group
@end smallexample

After such a printout, the @code{list} command with no arguments
prints ten lines centered on the point of execution in the frame.
@xref{List, ,Printing source lines}.

@table @code
@kindex frame
@cindex current stack frame
@item frame @var{args}
The @code{frame} command allows you to move from one stack frame to
another, and to print the stack frame you select.  @var{args} is the
the stack frame number;  @code{frame 0} then will always show the
current and most recent stack frame.

If a negative number is given, counting is from the other end of the
stack frame, so @code{frame -1} shows the least-recent, outermost or
most ``main'' stack frame.

Without an argument, @code{frame} prints the current stack
frame. Since the current position is redisplayed, it may trigger a
resynchronization if there is a front end also watching over
things.
@end table

@node List
@section Examining Source Files (@samp{list})

@value{DBG} can print parts of your script's source.  When your
script stops, @value{DBG} spontaneously prints the line where it
stopped.  Likewise, when you select a stack frame (@pxref{Selection,
,Selecting a frame}), @value{DBG} prints the line where execution in
that frame has stopped.  You can print other portions of source files
by explicit command.

If you use @value{DBG} through its @value{Emacs} interface, you may
prefer to use Emacs facilities to view source.

@kindex list
@kindex l @r{(@code{list})}
To print lines from a source file, use the @code{list} command
(abbreviated @code{l}).  By default, ten lines are printed.
There are several ways to specify what part of the file you want to print.

Here are the forms of the @code{list} command most commonly used:

@table @code
@item list @var{linenum}
@itemx l @var{linenum}
Print lines centered around line number @var{linenum} in the
current source file.

@item list @var{function}
@itemx l @var{function}
Print the text of @var{function}.

@item list
@itemx l
Print more lines.  If the last lines printed were printed with a
@code{list} command, this prints lines following the last lines
printed; however, if the last line printed was a solitary line printed
as part of displaying a stack frame (@pxref{Stack, ,Examining the
Stack}), this prints lines centered around that line.

@item list -
@itemx l -
Print lines just before the lines last printed.
@end table

By default, @value{DBG} prints ten source lines with any of these forms of
the @code{list} command.
You can change this using @code{set listsize}:

@table @code
@kindex set listsize
@item set listsize @var{count}
Make the @code{list} command display @var{count} source lines (unless
the @code{list} argument explicitly specifies some other number).

@kindex show listsize
@item show listsize
Display the number of lines that @code{list} prints.


@end table

Repeating a @code{list} command with @key{RET} discards the argument,
so it is equivalent to typing just @code{list}.  This is more useful
than listing the same lines again.  An exception is made for an
argument of @samp{-}; that argument is preserved in repetition so that
each repetition moves up in the source file.

@cindex linespec
In general, the @code{list} command expects you to supply a
@dfn{linespecs}.  Linespecs specify source lines; there are several ways
of writing them, but the effect is always to specify some source line.

Here is a complete description of the possible arguments for @code{list}:

@table @code
@item list @var{linespec}
Print lines centered around the line specified by @var{linespec}.

@item list @var{first} @var{increment}
Print @var{increment} lines starting from @var{first}

@item list @var{first}
Print lines starting with @var{first}.

@item list -
Print lines just before the lines last printed.

@item list .
Print lines after where the script is stopped.

@item list
As described in the preceding table.
@end table

Here are the ways of specifying a single source line---all the
kinds of linespec.

@table @code
@item @var{number}
Specifies line @var{number} of the current source file.
When a @code{list} command has two linespecs, this refers to
the same source file as the first linespec.

@item @var{filename}:@var{number}
Specifies line @var{number} in the source file @var{filename}.

@item @var{function}
Specifies the line that function @var{function} is listed on.

@ifset FINISHED
@item @var{filename}:@var{function}
Specifies the line of function @var{function} in the file
@var{filename}.  You only need the file name with a function name to
avoid ambiguity when there are identically named functions in
different source files.
@end ifset
@end table

@node Edit
@section Editing Source files (@samp{edit})

To edit the lines in a source file, use the @code{edit} command.  The
editing program of your choice is invoked with the current line set to
the active line in the program.  Alternatively, you can give a line
specification to specify what part of the file you want to print if
you want to see other parts of the program.

You can customize to use any editor you want by using the
@code{EDITOR} environment variable. The only restriction is that your
editor (say @code{ex}), recognizes the following command-line syntax:
@smallexample
ex +@var{number} file
@end smallexample
The optional numeric value +@var{number} specifies the number of the
line in the file where to start editing.  For example, to configure
@value{DBG} to use the @code{vi} editor, you could use these commands
with the @code{sh} shell:
@smallexample
EDITOR=/usr/bin/vi
export EDITOR
gdb @dots{}
@end smallexample
or in the @code{csh} shell,
@smallexample
setenv EDITOR /usr/bin/vi
gdb @dots{}
@end smallexample

@table @code
@kindex edit @ovar{line-specification}
@item edit @ovar{line specification}
Edit line specification using the editor specified by the
@code{EDITOR} environment variable.
@end table

@node Search
@section Searching source files (@samp{search}, @samp{reverse}, @samp{/.../}, @samp{?..?})
@cindex searching
@kindex reverse-search

There are two commands for searching through the current source file
for a @acronym{BASH} extended pattern-matching expression.

@table @code
@kindex search
@kindex forward
@item forward @var{bash-pattern}
@itemx search @var{bash-pattern}
The command @samp{forward @var{bash-pattern}} checks each line,
starting with the one following the current line, for a match for
@var{bash-pattern} which is an extended bash pattern-matching
expression.  It lists the line that is found.  You can use the synonym
@samp{search @var{bash-pattern}} or abbreviate the command name as
@code{fo} or @code{/@var{pat}/}.

@item reverse @var{bash-pattern}
The command @samp{reverse @var{bash-pattern}} checks each line, starting
with the one before the last line listed and going backward, for a match
for @var{bash-pattern}.  It lists the line that is found.  You can abbreviate
this command as @code{rev} or @code{?@var{bash-pattern}?}.
@end table

@node Data
@section Examining Data (@samp{print}, @samp{examine}, @samp{info variables})

@cindex printing data
@cindex examining data
@kindex print

One way to examine string data in your script is with the @code{print}
command (abbreviated @code{p}). However a more versatile print command
is @code{x}; it can print variable and function definitions and can do
arithmetic computations. Finally, the most general method would be
via @code{eval echo}.

@table @code
@kindex print
@kindex p @r{(@code{print})}
@item print @var{expr}

Use @code{print} to display strings as you would from @code{echo}. And
as such, variable names to be substituted have to be preceded with a
dollar sign. As with echo, filename expansion, e.g.@: tilde expansion,
is performed on unquoted strings. So for example if you want to print
a *, you would write @samp{print "*"}, not @samp{print *}. If you want
to have the special characters dollars sign appear, use a backslash.

@smallexample
@group
bashdb<0> @b{print the value of x is $x}
the value of x is 22
bashdb<1> @b{p The home directory for root is ~root}
The home directory for root is /root
bashdb<2> @b{p '*** You may have won $$$ ***'}
*** You may have won $$$ ***
bashdb<3> # Note the use of the single quotes.
bashdb<3> # Compare what happens with double quotes or no quotes
@end group
@end smallexample

@item print
@itemx p
If you omit @var{expr}, @value{DBG} displays the last expression again.

@item x @var{variable1} @ovar{variable2...}
@item x @var{expr}
@kindex x @r{(@code{examine})}
@kindex examine

This is a smarter, more versatile ``print'' command, and although sometimes
it might not be what you want, and you may want to resort to either
@code{print} or @code{eval echo...}.

As with @code{print}, if you omit @var{expr}, @value{DBG} displays
the last expression again.

The @code{x} command first checks if @var{expr} is variable or a list
of variables delimited by spaces. If it is, the definition(s) and
value(s) of each printed via @acronym{BASH}'s @code{declare -p}
command. This will show the variable's attributes such as if it is
read only or if it is an integer. If the variable is an array, that is
show and the array values are printed.

If instead @var{expr} is a function, the function definition is
printed via @acronym{BASH}'s @code{declare -f} command. If @var{expr}
was neither a variable nor an expression, then we try to get a value
via @code{let}. And if this returns an error, as a last resort we call
@code{print} and give what it outputs.

Since @code{let} may be used internally and since (to my thinking)
@code{let} does funny things, the results may seem odd unless you
understand the sequence tried above and how @code{let} works. For
``example if the variable @code{foo} has value 5, then @samp{x foo}
shows the definition of foo with value 5, and @samp{x foo+5} prints 10
as expected. So far so good. However if @code{foo} is has the value
@samp{alpha}, @samp{x foo+5} prints 5 because @code{let} has converted
the string @samp{alpha} into the numeric value 0. So @samp{p foo+5} will
simply print ``foo+5''; if you want the value of ``foo'' substituted
inside a string, for example you expect ``the value of foo is $foo''
to come out ``the value of foo is 5'', then the right command to use
is @code{print} rather than @code{x}, making sure you add the dollar
onto the beginning of the variable.

@smallexample
@group
bashdb<0> @b{examine x y}
declare -- x="22"
declare -- y="23"
bashdb<1> @b{examine x+y}
45
bashdb<2> @b{x fn1}
fn1 ()
@{
    echo "fn1 here";
    x=5;
    fn3
@}
bashdb<2> @b{x FUNCNAME}
declare -a FUNCNAME='([0]="_Dbg_cmd_x" [1]="_Dbg_cmdloop" [2]="_Dbg_debug_trap_handler" [3]="main")'
@end group
@end smallexample

@item V @ovar{!}@ovar{pattern}
@kindex V @r{(@code{info variables})}
@kindex info variables

If you want to all list variables and values or a set of
variables by pattern, use this command.

@smallexample
@group
bashdb<0> @b{V dq*}
dq_args="dq_*"
dq_cmd="V"
bashdb<1> @b{V FUNCNAME}
FUNCNAME='([0]="_Dbg_cmd_list_variables" [1]="_Dbg_cmdloop" [2]="_Dbg_debug_trap_handler" [3]="main")'
@end group
@end smallexample

@end table

@node Auto Display
@section Automatic display (@samp{display}, @samp{undisplay})
@cindex automatic display
@cindex display of expressions

If you find that you want to print the value of an expression
frequently (to see how it changes), you might want to add it to the
@dfn{automatic display list} so that @value{DBG} evaluates a
statement each time your program stops.  Each expression added to the
list is given a number to identify it; to remove an expression from
the list, you specify that number.  The automatic display looks like
this:

@example
2 (echo $x): 38
@end example

@noindent
This display shows item numbers, expressions and their current values.

@table @code
@kindex display
@item display @var{expr}
Add the expression @var{expr} to the list of expressions to display
each time your program stops.

@item display
Display the current values of the expressions on the list, just as is
done when your program stops.

@kindex delete display
@kindex undisplay @var{dnums}@dots{}
@item undisplay @var{dnums}@dots{}
@itemx delete display @var{dnums}@dots{}
Remove item numbers @var{dnums} from the list of expressions to display.

@code{undisplay} does not repeat if you press @key{RET} after using it.
(Otherwise you would just get the error @samp{No display number @dots{}}.)

@kindex disable display
@item disable display @var{dnums}@dots{}
Disable the display of item numbers @var{dnums}.  A disabled display
item is not printed automatically, but is not forgotten.  It may be
enabled again later.

@kindex enable display
@item enable display @var{dnums}@dots{}
Enable display of item numbers @var{dnums}.  It becomes effective once
again in auto display of its expression, until you specify otherwise.

@kindex info display
@item info display
Print the list of expressions previously set up to display
automatically, each one with its item number, but without showing the
values.  This includes disabled expressions, which are marked as such.
It also includes expressions which would not be displayed right now
because they refer to automatic variables not currently available.
@end table

@node Evaluation/Execution
@section Running Arbitrary BASH and Shell commands (@samp{eval}, @samp{shell})

The two most general commands and most ``low-level'' are @code{eval}
and @code{shell}.

@table @code
@item eval @r{[} bash-code @r{]}
@itemx e
@kindex e @r{(@code{eval})}
@kindex eval

In contrast to the commands of the last section the most general way
to examine data is through @code{eval}. But you do much more with
this; you can change the values of variables, since, you are just
evaluating @acronym{BASH} code.

If you expect output, you should arrange that in the command, such as
via @code{echo} or @code{printf}. For example, to print the value of
@var{foo}, you would type @samp{e echo $foo}. This is bit longer than
@samp{p $foo} or (when possible) @samp{x foo}. However suppose you
wanted to find out how the builtin test operator @samp{[} works with
the @samp{-z} test condition. You could use @code{eval} to do this
such as @samp{e [ -z "$foo"] && echo "yes"}.


@item eval

I find I sometimes want to run the line that's about to be executed to see if I want to step into methods that are called.

For example:

@smallexample
(/etc/apparmor/functions:24):
PROFILES="/etc/apparmor.d"
bashdb<2>
@end smallexample

I had been cutting and pasting the command as shown, but realized I could do better if I made a command for this. So that's what I've done.

If you run the @samp{eval} command without any arguments, it will run
the command that is about to be run.

@smallexample
(/etc/apparmor/functions:24):
PROFILES="/etc/apparmor.d"
bashdb<2> eval
eval: PROFILES="/etc/apparmor.d"
$? is 0
bashdb<3>
@end smallexample

This was working fine, until I started coming across tests inside @code{if}, @code{elsif},  @code{case}, @code{return} or @code{while} blocks. For example:

@smallexample
(/etc/init.d/apparmor:70):
if [ "$1" = "recache" ]
@end smallexample

Suppose I want to know which branch I'm going to take before taking the branch. That way I might even be able to change which way to go by changing the test before it runs in the debugged program. (In the above example, I could print $1

@smallexample
bashdb<2> pr $1
status
@end smallexample

But I'm lazy. I'd rather let the debugger do the work for me:

@smallexample
bashdb<1> eval?
eval: [ "$1" = "recache" ]
$? is 1
@end smallexample

If you alias eval with a name that ends in ? it will strip off any leading @code{if}, @code{case}, @code{while}, @code{elsif}, or @code{return}.


@kindex !! @r{(@code{shell})}
@cindex shell escape
@item !! @var{command string}

If you need to execute occasional shell commands during your
debugging session, there is no need to leave or suspend @value{DBG}; you can
just use the @code{shell} command or its alias @code{!!}.

Invoke a shell to execute @var{command string}.

@kindex shell @r{(@code{shell})}
@cindex nested shell
@item shell

Although the debugger allows one to evaluate arbitrary @acronym{BASH}
code using @code{eval}, or via the @code{set autoeval} mode, sometimes
you might prefer to work inside a @acronym{BASH} shell to see variables,
experiment, issue commands (using the currently-set up environment), and
even change variables and functions.

For this we, the debugger @code{shell} command, enters a nested shell
session. But before it does this, it saves out variable and function
definitions in the current context of the running program. That way, you
have access to those.

This however creates a new problem: getting changes you make reflected
back into the running program. Right now any variable you change can be
flagged to have its value re-read when the shell exits. This is done
using the @code{save_var} function inside the nested shell. @code{save_var}
takes a list of variable names.

Here is an example session

@smallexample
bashdb /etc/init.d/apparmor status
bashdb debugger, release 4.2-0.8

Copyright 2002, 2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011 Rocky Bernstein
This is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
...
(/etc/init.d/apparmor:35):
. /etc/apparmor/functions
bashdb<1> s
(/etc/apparmor/functions:24):
PROFILES="/etc/apparmor.d"
bashdb<2> s
(/etc/apparmor/functions:25):
PARSER="/sbin/apparmor_parser"
bashdb<3> shell
bashdb $ typeset -p PROFILES
typeset -p PROFILES
typeset PROFILES=/etc/apparmor.d
bashdb $ PROFILES='Hi, Mom!'
bashdb $ save_vars PROFILES
bashdb $  <EOF>
(/etc/apparmor/functions:25):
PARSER="/sbin/apparmor_parser"
bashdb<4> x PROFILES
typeset PROFILES='Hi, Mom!'
@end smallexample

Note that inside the nested shell the we have set the prompt has been
set to @code{bashdb $ }.
@end table

@node Interfacing to the OS
@section Interfacing to the OS (@samp{cd}, @samp{pwd})

@table @code
@kindex cd @ovar{directory}
@cindex change working directory
@item cd

Set working directory to @var{directory} for debugger and program
being debugged.  Tilde expansion, variable and filename expansion is
performed on @var{directory}. If no directory is given, we print out the
current directory which is really the same things as running
@code{pwd}.

Note that @code{gdb} is a little different in that it performs tilde expansion
but not filename or variable expansion and the directory argument is
not optional as it is here.

@kindex pwd
@cindex print working directory
@item pwd

Prints the working directory as the program sees things.

@end table

@node Information and Settings
@section Status and Debugger Settings (@samp{info}, @samp{show})

@menu
* Info::        Showing information about the program being debugged
* Show::        Show information about the debugger
@end menu

In addition to @code{help}, you can use the @acronym{BASH} commands @code{info}
and @code{show} to inquire about the state of your program, or the
state of @acronym{BASH} itself.  Each command supports many topics of inquiry;
here we introduce each of them in the appropriate context.  The
listings under @code{info} and under @code{show} in the Index point to
all the sub-commands.  @xref{Command Index}.

@node Info
@subsection Showing information about the program being debugged (@samp{info})
@c @group
This @code{info} command (abbreviated @code{i}) is for describing the state of
your program.  For example, you can list the current @code{$1}, @code{$2}
parameters with @code{info args}, or list the breakpoints you have set
with @code{info breakpoints} or @code{info watchpoints}.  You can get
a complete list of the @code{info} sub-commands with @w{@code{help
info}}.

@table @code
@kindex info args
@item info args
Argument variables (e.g.@: $1, $2, ...) of the current stack frame.
@kindex info breakpoints
@item info breakpoints
Status of user-settable breakpoints
@kindex info display
@item info display
Show all display expressions
@kindex info files
@item info files
Source files in the program
@kindex info functions
@item info functions
All function names
@kindex info line
@item info line
list current line number and and file name
@kindex info program
@item info program
Execution status of the program.
@kindex info signals
@item info signals
What debugger does when program gets various signals
@kindex info source
@item info source
Information about the current source file
@kindex info stack
@item info stack
Backtrace of the stack
@kindex info terminal
@item info terminal
Print terminal device
@kindex info variables
@item info variables
All global and static variable names
@end table

@c @end group

@node Show
@subsection Show information about the debugger (@samp{show})

In contrast to @code{info}, @code{show} is for describing the state of
@acronym{BASH} itself.  You can change most of the things you can
@code{show}, by using the related command @code{set};

The distinction between @code{info} and @code{show} however is a bit
fuzzy and is kept here to try to follow the GDB interface.
For example, to list the arguments given to your script use
@code{show args}; @code{info args} does something different.

Here are three miscellaneous @code{show} subcommands, all of which are
exceptional in lacking corresponding @code{set} commands:

@table @code
@kindex show version
@cindex version number
@item show version
Show what version of @acronym{BASH} is running.  You should include this
information in @acronym{BASH} bug-reports.  If multiple versions of
@acronym{BASH} are in use at your site, you may need to determine which
version of @acronym{BASH} you are running; as @acronym{BASH} evolves, new
commands are introduced, and old ones may wither away.  Also, many
system vendors ship variant versions of @value{BASH}, and there are
variant versions of @acronym{BASH} in @sc{gnu}/Linux distributions as well.
The version number is the same as the one announced when you start
@value{BASH}.

@kindex show copying
@item show copying
Display information about permission for copying @value{BASH}.

@item show linetrace

Show if line tracing is enabled. See also @ref{Line Tracing}.

@item show logging

Show summary information of logging variables which can be set via
@code{set logging}. See also @ref{Logging}.

@item show logging file

Show the current logging file.

@item show logging overwrite

Show whether logging overwrites or appends to the log file.

@kindex show warranty
@item show warranty
Display the @sc{gnu} ``NO WARRANTY'' statement, or a warranty,
if your version of @DBG comes with one.

@end table

@node Controlling bashdb
@section Controlling bashdb (@samp{set}, @samp{file}, @samp{prompt}, @samp{history}...)

You can alter the way @acronym{BASH}
interacts with you in various ways given below.

@menu
* Alias::                Debugger Command aliases
* Annotate::             Annotation Level (set annotate)
* Autoeval::             Evaluate unrecognized commands
* Autolist::             Run a list command on every stop
* Basename::             Show basenames of file names only (set basename)
* Debugger::             Allow debugging the debugger (set debugger)
* File::                 Specifying a Script-File Associaton (set file)
* Line Tracing::         Show position information (set linetrace)
* Logging::              Specifying where to write debugger output
* Prompt::               Prompt (set prompt, show prompt)
* Editing::              Command editing (set editing, show editing)
* Command-Tracing::      Showing commands as they run (set/show trace-commands)
* Command Display::      Command display (set showcommand)
* History::              Command history (history, !, H)
* Command Completion::   Command completion (complete)
@end menu

@node Alias
@subsection Debugger Command Aliases (@samp{alias})
@table @code
@kindex alias @var{name} @var{command}
@item alias @var{name} @var{command}
Add @var{name} as an alias for @var{command}

@kindex unalias @var{name} @var{command}
Remove @var{name} as an alias for @var{command}
@item unalias @var{name} @var{command}
@end table

@node Annotate
@subsection Annotation Level (@samp{set annotate})

@table @code
@kindex set annotate
@item set annotate @var{integer}
The annotation level controls how much information @value{DBG} prints
in its prompt; right new it just controls whether we show full
filenames in output or the base part of the filename without path
information.  Level 0 is the normal, level 1 is for use when
@value{DBG} is run as a subprocess of @value{Emacs} of @value{DDD},
level 2 is the maximum annotation suitable for programs that control
@value{DBG}.
@end table

@node Autoeval
@subsection Set/Show auto-eval (@samp{set autoeval})

@table @code
@kindex set autoeval @r{[} on | 1 | off | 0 @r{]}
@item set autoeval @r{[} on | 1 | off | 0 @r{]}
Specify that debugger input that isn't recognized as a command should
be passed to Ruby for evaluation (using the current debugged program
namespace). Note however that we @emph{first} check input to see if it
is a debugger command and @emph{only} if it is not do we consider it
as Ruby code. This means for example that if you have variable called
@code{n} and you want to see its value, you could use @code{p n},
because just entering @code{n} will be interpreted as the debugger
``next'' command.

When autoeval is set on, you'll get a different error message when you
invalid commands are encountered. Here's a session fragment to show
the difference
@smallexample
bashdb<1> @b{stepp}
Unknown command
bashdb<2> @b{set autoeval on}
autoeval is on.
bashdb<3> @b{stepp}
NameError Exception: undefined local variable or method `stepp' for ...
@end smallexample

@kindex show autoeval
@item show args
Shows whether Ruby evaluation of debugger input should occur or not.
@end table

@node Autolist
@subsection Set/Show listing on stop (@samp{set autolist})

@table @code
@kindex set autolist @r{[} on | 1 | off | 0 @r{]}
@item set autolist @r{[} on | 1 | off | 0 @r{]}
When set runs a ``list'' command on each stop in the debugger.
@end table

@node Basename
@subsection File basename (@samp{set basename})

@table @code
@kindex set basename
@item set basename @r{[} on | 1 @r{]}
When set on, source filenames are shown as the shorter ``basename''
only. (Directory paths are omitted). This is useful in running the
regression tests and may useful in showing debugger examples as in
this text. You may also just want less verbose filename display.

@item set basename @r{[} off | 0 @r{]}
Source filenames are shown as with their full path. This is the default.
@end table

@node Debugger
@subsection Allow Debugging the debugger (@samp{set debugger})

@table @code
@kindex set debugger
@item set debugger @r{[} on | 1 @r{]}
Allow the possibility of debugging this debugger. Somewhat of an
arcane thing to do. For gurus, and even he doesn't use it all that
much.
@item set debugger @r{[} off | 0 @r{]}
Don't allow debugging into the debugger. This is the default.
@end table

@node File
@subsection Specifying a Script-File Association (@samp{file})

Sometimes @value{DBG} gets confused about where to find the script
source file for the name reported to it by bash. To resolve relative
file names that bash supplies via @env{BASH_SOURCE}, @value{DBG} uses
the current working directory when the debugged script was started as
well as the current working directory now (which might be different
if a ``cd'' command was issued to change the working directory).

However sometimes this doesn't work and there is a way to
override this.

@table @code
@kindex file
@item file @var{script-file}
Directs @value{DBG} to use @var{script-file} whenever bash would have
it refers to the filename given in @env{BASH_SOURCE}. The filename
specified in @env{BASH_SOURCE} that gets overridden is shown when is
this command is issued.
@end table

@node Line Tracing
@subsection Show position information as statements are executed (@samp{set linetrace})

@value{BASH} has ``@code{set -x}'' tracing to show commands as they are
run. However missing from this is file and line position
information. So the debugger compensates here for what I think is
deficiency of @value{BASH} by providing this information. The downside
is that this tracing is slower than the built-in tracing of
@value{BASH}.

The status of whether line tracing is enabled can be show via
@code{show linetrace}.

@table @code
@kindex set linetrace
@item set linetrace @r{[} on | 1 @r{]}
Turn on line tracing.
@item set linetrace @r{[} off | 0 @r{]}
Turn off line tracing.
@end table

@node Logging
@subsection Logging output (@samp{set logging}, @samp{set logging file}...)

You may want to save the output of the debugger commands to a file.
There are several commands to control the debuggers's logging.

@table @code
@item set logging
Prints @code{set logging} usage.
@kindex set logging
@item set logging @r{[} on | 1 @r{]}
Enable or Disable logging.
@item set logging file @var{filename}
Change the name of the current logfile.  The default logfile is
@file{bashdb.txt}.
@item set logging overwrite @r{[} on | 1 @r{]}
By default, the debugger will append to the logfile.  Set
@code{overwrite} if you want @code{set logging on} to overwrite the
logfile instead.
@item set logging redirect @r{[} on | 1 @r{]}
By default, the debugger output will go to both the terminal and the
logfile.  Set @code{redirect} if you want output to go only to the log
file.
@item show logging
Show the current values of the logging settings.
@end table

@node Prompt
@subsection Prompt (@samp{set prompt}, @samp{show prompt})

@cindex prompt

@value{dBGP} indicates its readiness to read a command by printing a
string called the @dfn{prompt}.  This string is normally:
@example
bashdb$@{_Dbg_less@}$@{#_Dbg_history[@@]@}$@{_Dbg_greater@}$_Dbg_space
@end example

When variables inside the the prompt string are evaluated, the above
becomes something like @samp{bashdb<5>} if this is the fifth command
executed or perhaps @samp{bashdb<<2>>} if you have called the debugger
from inside a debugger session and this is the second command inside
the debugger session or perhaps @samp{bashdb<(6)>} if you
entered a subshell after the fifth command.

You can change the prompt string with the @code{set prompt} command,
although it is not normally advisable to do so without understanding
the implications. If you are using the @value{DDD} GUI, it changes the
changes the prompt and should not do so.  In certain other
circumstances (such as writing a GUI like @value{DDD}), it may be is useful
to change the prompt.

@emph{Note:} @code{set prompt} does not add a space for you after the
prompt you set.  This allows you to set a prompt which ends in a space
or a prompt that does not. Furthermore due to a implementation
limitation (resulting from a limitation of the bash built-in function
``read''), to put a space at the end of the prompt use the
@samp{$_Dbg_space} variable.

@table @code
@kindex set prompt
@item set prompt @var{newprompt}
Directs @value{DBG} to use @var{newprompt} as its prompt string
henceforth.

@emph{Warning: changing the prompt can @value{DDD}'s ability to
understand when the debugger is waiting for input.}

@kindex show prompt
@item show prompt
Prints a line of the form: @samp{bashdb's prompt is: @var{your-prompt}}
@end table

@node Editing
@subsection Command editing (@samp{set editing}, @samp{show editing})
@cindex readline
@cindex command line editing

@value{DBG} reads its input commands through bash which uses via the
@dfn{readline} interface.  This @sc{gnu} library provides consistent
behavior for programs which provide a command line interface to the
user.  Advantages are @value{Emacs}-style or @dfn{vi}-style inline
editing of commands, @code{csh}-like history substitution, and a
storage and recall of command history across debugging sessions.

You may control the behavior of command line editing in @acronym{BASH} with the
command @code{set}.

@table @code
@kindex set editing
@cindex editing
@item set editing
@itemx set editing @r{[} on | 1 @r{]}
Enable command line editing (enabled by default).

@item set editing @r{[} off | 0 @r{]}
Disable command line editing.

@kindex show editing
@item show editing
Show whether command line editing is enabled.
@end table


@node Command-Tracing
@subsection Debugger Commands Tracing (@samp{set trace-commands}, @samp{show trace-commands})
@cindex tracing debugger commands
If you need to debug user-defined commands or sourced files you may find it
useful to enable @dfn{command tracing}.  In this mode each command will be
printed as it is executed, prefixed with one or more @samp{+} symbols, the
quantity denoting the call depth of each command.

@table @code
@kindex set trace-commands
@cindex command scripts, debugging
@item set trace-commands on
Enable command tracing.
@item set trace-commands off
Disable command tracing.
@item show trace-commands
Display the current state of command tracing.
@end table

@node Command Display
@subsection Command Display (@samp{set showcommand})

The debugger normally lists the line number and source line of the for
the statement to be next executed. Often this line contains one
expression or one statement and it is clear from this line what's
going to happen. However @acronym{BASH} allows many expressions or
statements to be put on a single source line; some lines
contain several units of execution. Some examples of this
behavior are listed below:

@smallexample
x=1; y=2; x=3
(( x > 5 )) && x=5
y=`echo *`
@end smallexample

In the first line of the example above, we have three assignment
statements on a single line. In the second line of the example above
we have a statement which gets run only if a condition tests true. And
in the third line of the example above, we have a command that gets
run and then the output of that is substituted in an assignment
statement.  If you were single stepping inside the debugger, each line
might get listed more than once before each of the actions that might
get performed. (In the case of the conditional statement, the
line gets listed only once when the condition is false.)

In order to assist understanding where you are, the enhanced version
of @acronym{BASH} maintains a dynamic variable @env{BASH_COMMAND} that
contains piece of code next to be run (or is currently being run). The
debugger has arranged to save this and can display this information
or not. This is controlled by @code{set showcommand}.

@table @code
@kindex set showcommand
@item set showcommand @r{[}auto | on | 1 | off | 0 @r{]}
controls whether or not to show the saved @env{BASH_COMMAND} for the
command next to be executed.
@end table

When the value is @code{auto} the following heuristic is used to
determine whether or not to display the saved @env{BASH_COMMAND}. If
the last time you stopped you were at the same place and the command
string has changed, then show the command. When the value @code{on} is
used, the debugger always shows @env{BASH_COMMAND} and when
@code{off} is used, the debugger never shows
@env{BASH_COMMAND}. Note that listing the text of the source line is
independent of whether or not the command is also listed.

Some examples:
@smallexample
set showcommand auto      @b{This is the default}
set showcommand on        @b{Always show the next command to be executed}
set showcommand off       @b{Never show the next command to be executed}
@end smallexample

@node History
@subsection Command history (@samp{H}, @samp{history}, @samp{!})

@value{dBGP} can keep track of the commands you type during your
debugging sessions, so that you can be certain of precisely what
happened.  If the prompt has not been changed (see @ref{Prompt,
,Prompt}), the history number that will be in use next is by default
listed in the debugger prompt. Invalid commands and history commands
are not saved on the history stack.

@table @code
@kindex H @r{[}@var{start-number} @ovar{end-number}@r{]}
@item H @r{[}@var{start-number} @ovar{end-number}@r{]}
@item H @ovar{-count}
@itemx !@r{[}-@r{]}@var{n}:p

You can list what is in the history stack with @code{H}. Debugger
commands in the history stack are listed from most recent to least recent.
If no @var{start-number} is given we start with the most recently
executed command and end with the first entry in the history stack.
If @var{start-number} is given, that history number is listed first. If
@var{end-number} is given, that history number is listed last. If a
single negative number is given list that many history commands.

An alternate form is @code{!@emph{n}:p} or @code{!-@emph{n}:p} where
@emph{n} is an integer. If a minus sign is used, @emph{n} is taken as
the count to go back from the end rather than as a absolute history
number. In contrast @code{H}, this form only prints a @emph{single}
history item.

Some examples:
@smallexample
H      @b{List entire history}
H -2   @b{List the last two history items}
!-2:p  @b{List a single history item starting at the same place as above}
H 5    @b{List history from history number 5 to the beginning (number 0)}
H 5 0  @b{Same as above}
H 5 3  @b{List history from history number 5 down to history number 3}
!5:p   @b{List a single history item 5}
@end smallexample

@kindex history @r{[}-@r{]}@r{[}@var{n}@r{]}
@kindex !@r{[}-@r{]}@var{n} @r{(@code{history})}
@item history @r{[}@r{[}-@r{]}@var{n}@r{]}
@itemx !@r{[}-@r{]}@var{n}

Use this command to reexecute a given history number. If no number is
given, the last debugger command in the history is executed.

An alternate form is @code{!@emph{n}} or @code{!-@emph{n}} where
@emph{n} is an integer.

If a minus sign is used in in either form, @emph{n} is taken as the
count to go back from the end rather than as a absolute history
number.

@end table

Use these commands to manage the @value{DBG} command
history facility.

@table @code
@ifset FINISHED
@cindex history substitution
@cindex history file
@kindex set history filename
@kindex GDBHISTFILE
@item set history filename @var{fname}
Set the name of the @acronym{BASH} command history file to @var{fname}.
This is the file where @acronym{BASH} reads an initial command history
list, and where it writes the command history from this session when it
exits.  You can access this list through history expansion or through
the history command editing characters listed below.  This file defaults
to the value of the environment variable @code{GDBHISTFILE}, or to
@file{./.gdb_history} (@file{./_gdb_history} on MS-DOS) if this variable
is not set.
@end ifset

@cindex history save
@kindex set history save
@item set history save
@itemx set history save @r{[} on | 1 @r{]}
Record command history in a file, whose name may be specified with the
@code{set history filename} command.  By default, this option is enabled.

@item set history save @r{[} off | 0 @r{]}
Stop recording command history in a file.

@cindex history size
@kindex set history size
@item set history size @var{size}
Set the number of commands which @acronym{BASH} keeps in its history list.
This defaults to the value of the environment variable
@code{HISTSIZE}, or to 256 if this variable is not set.
@end table

@ifset FINISHED
@cindex history expansion
History expansion assigns special meaning to the character @kbd{!}.

Since @kbd{!} is also the logical not operator in C, history expansion
is off by default. If you decide to enable history expansion with the
@code{set history expansion on} command, you may sometimes need to
follow @kbd{!} (when it is used as logical not, in an expression) with
a space or a tab to prevent it from being expanded.  The readline
history facilities do not attempt substitution on the strings
@kbd{!=} and @kbd{!(}, even when history expansion is enabled.

The commands to control history expansion are:
@end ifset

@table @code
@ifset FINISHED
@kindex set history expansion
@item set history expansion on
@itemx set history expansion
Enable history expansion.  History expansion is off by default.

@item set history expansion off
Disable history expansion.

The readline code comes with more complete documentation of
editing and history expansion features.  Users unfamiliar with @value{Emacs}
or @code{vi} may wish to read it.
@end ifset

@c @group
@kindex show history
@item show history
@ifset FINISHED
@itemx show history filename
@itemx show history expansion
@end ifset
@itemx show history save
@itemx show history size
These commands display the state of the @acronym{BASH} history parameters.
@code{show history} by itself displays all states.
@c @end group
@end table

@table @code
@kindex shows
@item show commands
Display the last ten commands in the command history.

@item show commands @var{n}
Print ten commands centered on command number @var{n}.

@item show commands +
Print ten commands just after the commands last printed.
@end table

@node Command Completion
@subsection Command Completion (@samp{complete})

The @code{complete @var{args}} command lists all the possible
completions for the beginning of a command.  We can also show
completions for @code{set}, @code{show} and @code{info}
subcommands. Use @var{args} to specify the beginning of the command
you want completed.  For example:

@smallexample
complete d
@end smallexample

@noindent results in:

@smallexample
@group
d
debug
delete
disable
display
deleteall
down
@end group
@end smallexample

And
@smallexample
complete set a
@end smallexample

@noindent results in:

@smallexample
@group
set args
set annotate
@end group
@end smallexample

@noindent This is intended for use by front-ends such as @sc{gnu}
Emacs and @sc{ddd}.

@node BASH Debugger Bugs
@chapter Reporting Bugs
@cindex bugs
@cindex reporting bugs

Your bug reports play an essential role in making the @acronym{BASH}
debugger reliable.

Reporting a bug may help you by bringing a solution to your problem, or it
may not.  But in any case the principal function of a bug report is to help
the entire community by making the next version of @value{DBG} work better.  Bug
reports are your contribution to the maintenance of @value{DBG}.

In order for a bug report to serve its purpose, you must include the
information that enables us to fix the bug.

@menu
* Bug Criteria::                Have you found a bug?
* Bug Reporting::               How to report bugs
@end menu

@node Bug Criteria
@section Have you found a bug?
@cindex bug criteria

If you are not sure whether you have found a bug, here are some guidelines:

@itemize @bullet
@cindex fatal signal
@cindex debugger crash
@cindex crash of debugger
@item
If the debugger gets a fatal signal, for any input whatever, that is a
@value{DBG} bug.  Reliable debuggers never crash.

@cindex error on valid input
@item
If @value{DBG} produces an error message for valid input, that is a
bug.  (Note that if you're cross debugging, the problem may also be
somewhere in the connection to the target.)

@cindex invalid input
@item
If @value{DBG} does not produce an error message for invalid input,
that is a bug.  However, you should note that your idea of
``invalid input'' might be our idea of ``an extension'' or ``support
for traditional practice''.

@item
If you are an experienced user of debugging tools, your suggestions
for improvement of @value{DBG} are welcome in any case.
@end itemize

@node Bug Reporting
@section How to report bugs
@cindex bug reports
@cindex BASH debugger bugs, reporting

Bug reports can sent via the sourceforge bug tracking mechanism at
@url{http://sourceforge.net/tracker/?group_id=61395&atid=497159}. Of
course patches are very much welcome too. Those can also be sent via
the same mechanism.

The fundamental principle of reporting bugs usefully is this:
@strong{report all the facts}.  If you are not sure whether to state a
fact or leave it out, state it!

Often people omit facts because they think they know what causes the
problem and assume that some details do not matter.  Thus, you might
assume that the name of the variable you use in an example does not matter.
Well, probably it does not, but one cannot be sure.  Perhaps the bug is a
stray memory reference which happens to fetch from the location where that
name is stored in memory; perhaps, if the name were different, the contents
of that location would fool the debugger into doing the right thing despite
the bug.  Play it safe and give a specific, complete example.  That is the
easiest thing for you to do, and the most helpful.

Keep in mind that the purpose of a bug report is to enable us to fix the
bug.  It may be that the bug has been reported previously, but neither
you nor we can know that unless your bug report is complete and
self-contained.

Sometimes people give a few sketchy facts and ask, ``Does this ring a
bell?''  Those bug reports are useless, and we urge everyone to
@emph{refuse to respond to them} except to chide the sender to report
bugs properly.

To enable us to fix the bug, you should include all these things:

@itemize @bullet
@item
The version of @value{DBG}.  @value{DBG} announces it if you start
with no arguments; you can also print it at any time using @code{version}
command.

Without this, we will not know whether there is any point in looking for
the bug in the current version of @value{DBG}.

@item
The type of machine you are using, and the operating system name and
version number.

@item
What compiler (and its version) was used to compile BASH---e.g.
``gcc 3.4''.

@item
The command arguments you gave the compiler to compile your example and
observe the bug.  For example, did you use @samp{-O}?  To guarantee
you will not omit something important, list them all.  A copy of the
Makefile (or the output from make) is sufficient.

If we were to try to guess the arguments, we would probably guess wrong
and then we might not encounter the bug.

@item
A complete input script, and all necessary source files, that will
reproduce the bug.

@item
A description of what behavior you observe that you believe is
incorrect.  For example, ``It gets a fatal signal.''

Of course, if the bug is that @value{DBG} gets a fatal signal, then we
will certainly notice it.  But if the bug is incorrect output, we might
not notice unless it is glaringly wrong.  You might as well not give us
a chance to make a mistake.

Even if the problem you experience is a fatal signal, you should still
say so explicitly.  Suppose something strange is going on, such as, your
copy of @value{DBG} is out of synch, or you have encountered a bug in
the C library on your system.  (This has happened!)  Your copy might
crash and ours would not.  If you told us to expect a crash, then when
ours fails to crash, we would know that the bug was not happening for
us.  If you had not told us to expect a crash, then we would not be able
to draw any conclusion from our observations.

@item
If you wish to suggest changes to the @value{DBG} source, send us context
diffs.  If you even discuss something in the @value{DBG} source, refer to
it by context, not by line number.

The line numbers in our development sources will not match those in your
sources.  Your line numbers would convey no useful information to us.

@end itemize

Here are some things that are not necessary:

@itemize @bullet
@item
A description of the envelope of the bug.

Often people who encounter a bug spend a lot of time investigating
which changes to the input file will make the bug go away and which
changes will not affect it.

This is often time consuming and not very useful, because the way we
will find the bug is by running a single example under the debugger
with breakpoints, not by pure deduction from a series of examples.
We recommend that you save your time for something else.

Of course, if you can find a simpler example to report @emph{instead}
of the original one, that is a convenience for us.  Errors in the
output will be easier to spot, running under the debugger will take
less time, and so on.

However, simplification is not vital; if you do not want to do this,
report the bug anyway and send us the entire test case you used.

@item
A patch for the bug.

A patch for the bug does help us if it is a good one.  But do not omit
the necessary information, such as the test case, on the assumption that
a patch is all we need.  We might see problems with your patch and decide
to fix the problem another way, or we might not understand it at all.

Sometimes with a program as complicated as @value{DBG} it is very hard to
construct an example that will make the program follow a certain path
through the code.  If you do not send us the example, we will not be able
to construct one, so we will not be able to verify that the bug is fixed.

And if we cannot understand what bug you are trying to fix, or why your
patch should be an improvement, we will not install it.  A test case will
help us to understand.

@item
A guess about what the bug is or what it depends on.

Such guesses are usually wrong.  Even we cannot guess right about such
things without first using the debugger to find the facts.
@end itemize

@node History and Acknowledgments
@chapter History and Acknowledgments

The suggestion for a debugger for a Bourne-like shell came from the book
``Learning the Korn Shell'', by Bill Rosenblatt Copyright (C) 1993 by
O'Reilly and Associates, Inc. Others such as Cigy Cyriac, Chet Ramey,
Rocky Bernstein, and Gary V. Vaughan expanded and improved on that.

However Bourne-Shell debuggers rely on a signal mechanism
(@code{SIGDEBUG}) to call a debugger routine. In the Korn shell as
well as @sc{bash} in versions prior to 2.05, there was a fundamental
flaw: the routine that you registered in the trap, got called
@emph{after} the statement was executed. It takes little imagination
to realize that this is a bit too late to find and correct errors,
especially if the offending command happens to do serious damage like
remove filesystems or reboot a server. As a horrible hack, these
debuggers added one to the line number that was just executed on the
wishful thinking that this would then be the line of next statement to
execute. Sometimes this was correct, but it was too often wrong, such
as in loops and conditionals, comments, or commands that are continued
on the next line.

Another failing of these debuggers was the inability to debug into
functions or into sourced files, provide a stack trace, dynamically
skip a statement to be run, unconditionally trace into a function or
subshell, or stop when a subroutine, sourced file, or subshell
completed. In truth, the crux of the problem lay in debugging support
in BASH. Given that there was limited bash debugging support, it is
not surprising that these debuggers could not do any of the things
listed above and could debug only a single shell in a single source
file: lines could be listed only from a single text, breakpoints were
set into the text which was in fact a copy of the script name
prepended with debugger routines.

In version 2.04 of BASH, Rocky Bernstein started hacking on BASH to
add call-stack information, source file information, allow for
debugging into functions and for reporting line numbers in functions
as relative to the file rather than the beginning of a function whose
origin line number was not accessible from BASH. He started changing
the user commands in bashdb to be like other more-advanced debuggers,
in particular @code{perl5db} and @code{gdb}. However he gave up on
this project when realizing that stopping before a line was crucial. A
patch for this was nontrivial and wildly changed
semantics. Furthermore the chance of getting his other patches into
BASH was was not going to happen in version 2.04.

In version 2.05, the fundamental necessary change to the semantics of
@code{SIGDEBUG} trap handling (suggested at least two years earlier)
was made. Also, version 2.05 changed the line-number reporting in a
function to be relative to the beginning of the file rather than the
beginning of a function---sometimes. Rocky then picked up where he
left off and this then became this debugger. A complete rewrite of the
debugger, some of which started in 2.04 was undertaken. Debugger
internals were changed to support multiple file names, save and
restore the calling environment (such as variables @code{$1} and
@code{$?}) and install debugger signal handlers. Work was also done on
the BASH in conjunction with the debugger to save stack trace
information, provide a means for stopping after a routine finished,
debugging into a subshell and so on. And a number of changes were made
to BASH just to improve the accuracy of the line number reporting
which is crucial in a debugger.

This documentation was modified from the GNU Debugger (GDB) Reference
manual.

@quotation
Additions to this section are particularly welcome.  If you or your
friends (or enemies, to be evenhanded) have been unfairly omitted from
this list, we would like to add your names!
@end quotation

The following have contributed directly or indirectly to @emph{bashdb}:

Rocky Bernstein (initial full-featured bashdb with stack tracing and
multi-file support)

Masatake YAMATO (help to merge Rocky's hack to the official bash source tree)

Rod Smith (for creating and hosting a nicely formatted version of this
manual that you are probably reading online)

Bill Rosenblatt (kshdb),
Michael Loukides (kshdb),
Cigy Cyriac (proto bashdb),
Chet Ramey (proto bashdb),
and
Gary V. Vaughan (proto bashdb).

Authors of per5ldb:

Ray Lischner,
Johan Vromans,
and
Ilya Zakharevich.

Authors of GDB:

Richard Stallman,
Andrew Cagney,
Jim Blandy,
Jason Molenda,
Stan Shebs,
Fred Fish,
Stu Grossman,
John Gilmore,
Jim Kingdon,
and
Randy Smith (to name just a few).

Authors of GUD:

Eric S. Raymond.

@c The readline documentation is distributed with the readline code
@c and consists of the two following files:
@c     rluser.texinfo
@c     inc-hist.texinfo
@c Use -I with makeinfo to point to the appropriate directory,
@c environment var TEXINPUTS with TeX.
@c @include rluser.texinfo
@c @include hsuser.texinfo

@include gpl.texi

@include fdl.texi

@node Command Index
@unnumbered Command Index
@printindex ky

@node General Index
@unnumbered General Index
@printindex cp

@c @tex
@c % I think something like @colophon should be in texinfo.  In the
@c % meantime:
@c \long\def\colophon{\hbox to0pt{}\vfill
@c \centerline{The body of this manual is set in}
@c \centerline{\fontname\tenrm,}
@c \centerline{with headings in {\bf\fontname\tenbf}}
@c \centerline{and examples in {\tt\fontname\tentt}.}
@c \centerline{{\it\fontname\tenit\/},}
@c \centerline{{\bf\fontname\tenbf}, and}
@c \centerline{{\sl\fontname\tensl\/}}
@c \centerline{are used for emphasis.}\vfill}
@c \page\colophon
@c % Blame: doc@cygnus.com, 1991.
@c @end tex

@bye
