Here we have a gdb-like debugger for Bash 3.0 and higher.

There are 3 ways to get into the debugger. If bash (with debugger
support enabled which is the default) is installed and the debugger
are *both* installed properly. Then:

   bash --debugger -- bash-script-name script-arg1 script-arg2...

If bash isn't installed in a way that will find bashdb, then:

   bashdb [bashdb-opts] -- bash-script-name script-arg1 script-arg2...

The downside here is that $0 will be "bashdb" not
bash-script-name. Also call stack will show the invocation to bashdb.

Finally, to invoke the debugger from the script

  # my script
  # work, work, work, ...

  # Load debugger support
  source <bashdb-installation>/bashdb-trace -L <basdb-installation>
  # work, work, work or not...
  _Dbg_debugger   # Calls the debugger at the line below
  stop_here

An advantage of the above is that there is no overhead up until you
invoke the debugger. Typically for large bash programs like
configuration scripts, this is a big win.

See INSTALL for generic GNU configure installation instructions.
